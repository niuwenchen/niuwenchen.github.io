<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SpeechAndLanguageProcessing">
<meta property="og:url" content="http://niuwenchen.github.io/index.html">
<meta property="og:site_name" content="SpeechAndLanguageProcessing">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpeechAndLanguageProcessing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://niuwenchen.github.io/"/>





  <title>SpeechAndLanguageProcessing</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SpeechAndLanguageProcessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">translate and learning language model</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Solidity-Localtion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Solidity-Localtion/" itemprop="url">Solidity Localtion </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T11:18:46+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Location</h2>
<pre><code>pragma solidity ^0.4.9;

contract Loc1{
struct S{string a;uint b;}

//parameter is memory
function assign(S s) internal{
    // local variable is storage
    S memory tmp =s;
}
}
</code></pre>
<p>// convert storage to storage</p>
<pre><code>contract Loc2{
struct S{string a;uint b;}

S s;

function convertToStorage(S storage  s) internal{
    S tmp =s;
    tmp.a = &quot;Test&quot;;
}
function call()  constant returns  (string str)
{
    convertToStorage(s);
    return s.a; //Test
}
}
</code></pre>
<p>// memory to state variable</p>
<pre><code>contract Loc3{
struct S{string a;uint b;}

S s;

function memoryToState(S memory tmp) internal{
    s = tmp;
    tmp.a =&quot;Test&quot;;
}
function call() constant returns (string)
{
    S memory tmp = S(&quot;memory&quot;,0);
    memoryToState(tmp);
    return s.a;
}
}
</code></pre>
<p>// memory to Local variable</p>
<pre><code>contract Loc4 {
struct S{string a;uint b;}
function memoryToLocal(S s) internal{
    // Error
    // S tmp =s;
    S memory tmp =s;
}
}
</code></pre>
<p>// storage to memory</p>
<pre><code>contract Loc5{
struct S{string a;uint b;}

// storage variable
S s= S(&quot;storage&quot;,1);

function storageToMemory(S storage x) internal{
    // storage to memory
    S memory tmp= x;
    tmp.a = &quot;Text&quot;;
}
function call() constant returns (string){
    storageToMemory(s);
    return s.a;
}
}


contract Loc6{
struct S{string a;uint b;}

function memoryToMemory(S s ) internal{
    S memory tmp =s;
    tmp.a = &quot;other memory&quot;;
}
function call() constant returns (string)
{
    S memory mem = S(&quot;memory&quot;,1);
    memoryToMemory(mem);
    return mem.a;
}
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Spark/" itemprop="url">Spark</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T10:40:23+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/15/solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/solidity/" itemprop="url">solidity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-15T13:44:07+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Tutorials</h2>
<pre><code>pragma solidity ^0.4.9;

contract SimpleStorage {
uint data;

function setData(uint x) public{
    
    data = x;
}

function getData() public constant returns (uint)  {
    
    return data;
}
}
</code></pre>
<h2>使用Truffle 部署测试协议</h2>
<pre><code>mkdir hello-world
cd hello-world
truffle init

truffle test

...
</code></pre>
<p>建立协议</p>
<pre><code>truffle create contract HelloWorld
contracts/HelloWorld.sol

pragma solidity ^0.4.9;

contract HelloWorld {
address private creator;
address private lastCaller;
string private message;
uint private totalGas;



function HelloWorld(){
     /*
  We can use the special variable `tx` which gives us information
  about the current transaction.

  `tx.origin` returns the sender of the transaction.
  `tx.gasprice` returns how much we pay for the transaction
	*/
    creator = tx.origin;
    totalGas = tx.gasprice;
    message = &quot;Hello World&quot;;
}

function getMesage() constant returns (string) {
    return message;
}

function getLastCaller() constant returns(address){
    return lastCaller;
}
function getCreator() constant returns (address){
    return creator;
}
function getTotalGas() constant returns(uint) {
return totalGas;
}
//End: getters

//Being: setters
function setMessage(string newMessage) {
message = newMessage;
lastCaller = tx.origin;
totalGas += tx.gasprice;
}
}
</code></pre>
<p>Migration:我们完成了一个协议，需要用一种方式将这个协议部署到区块链中。truffle使用migration方式，压缩和部署contracts</p>
<pre><code>truffle create migration 
生成一个文件: 1521178244_deploy_hello_world.js

在js文件中部署协议

const HelloWorld = artifacts.require('HelloWorld')
	module.exports = function(deployer) {
deployer.deploy(HelloWorld)
};
</code></pre>
<p>需要将协议部署到测试区块链中  truffle migrate --reset</p>
<p>Testing</p>
<pre><code>truffle create test HelloWorld
test/hello_world.js

const HelloWorld = artifacts.require('HelloWorld')

contract('HelloWorld', function(accounts) {
it('sets the first account as the contract creator', async function() {
		const contract = await HelloWorld.deployed()
		const creator = await contract.getCreator()
		
		assert.equal(creator, accounts[0],'main account is the creator')
})
it('has hello world as initial message' ,async function(){
				const contract = await HelloWorld.deployed()
				
				const message = await contract.getMesage()
				assert.equal(message, 'Hello World', 'message is hola mundo')
		})
it('changes the message via setMessage', async function() {
const contract = await HelloWorld.deployed()

// Execute a transaction and change the state of the contract.
await contract.setMessage('hola mundo')

// Get the new state.
const message = await contract.getMesage()

assert.equal(message, 'hola mundo', 'message is hola mundo')
})
});
</code></pre>
<p>使用测试命令</p>
<pre><code>truffle test
测试输出

Contract: HelloWorld
√ sets the first account as the contract creator
√ has hello world as initial message
√ changes the message via setMessage (91ms)
</code></pre>
<p>解析这个过程 <a href="https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/" target="_blank" rel="noopener">https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/</a></p>
<p>1 协议文件</p>
<pre><code>构造函数中一个变量tx

首先看下面的全局变量

block.coinbase(address): 当前块的矿场的地址
block.difficulty(uint) : 当前块的难度
block.gaslimit(uint)   : 当前块的gaslimit
block.number(uint)     : 当前块的数量
block.blockhash(function(uint) returns(bytes32)): 给定的块的hash值，只有最近工作的256块的hash值
block.timestamp(uint)  ： 当前块的时间戳
msg.data(bytes)			: 完整的calldata
msg.gas(uint)			: 剩余gas
msg.sender(address)		: 消息的发送者
msg.value(uint)			: 和消息一起发送的wei的数量
now(uint):				当前块的时间戳(block.timestamp的别名)
tx.gasprice(uint):		交易的gas价格
tx.origin(address):		交易的发送者(全调用链)
sha3(...) retuens (bytes32): 计算(紧凑排列的) 参数的 Etherum-SHA3 hash值
sha256(...) returns (bytes32): 计算(紧凑排列的)参数的SHA256 hash值
ripemd160(...) returns (bytes20): 计算256个参数的RIPEMD
ecrecover(bytes32, uint8, bytes32, bytes32) returns (address):椭圆曲线签名公钥恢复
addmod(uint x, uint y, uint k) returns (uint):计算（x + y）K，加法为任意精度，不以2 ** 256取余
mulmod(uint x, uint y, uint k) returns (uint):计算（XY）K，乘法为任意精度，不以2 * 256取余
this (current contract’s type): 当前合约，在地址上显式转换
super:在层次关系上一层的合约
selfdestruct(address):销毁当前的合同，将其资金发送到指定address地址
.balance:address地址中的账户余额（以wei为单位）
.send(uint256) returns (bool):将一定量wei发送给address地址，若失败返回false。
</code></pre>
<p>contract中的分析</p>
<pre><code>creator = tx.origin;  //交易的发送者，协议的关联者，
这里和第一个account账户关联
totalGas = tx.gasprice;
message = &quot;Hello World&quot;;

const contract = await HelloWorld.deployed()
const creator = await contract.getCreator()
console.log(creator)
console.log(accounts[0])

0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278

tx.gasprice: BigNumber { s: 1, e: 11, c: [ 100000000000 ] }

也就是在部署这个协议的时候，默认将accounts作为tx.origin，那么协议的发送者是谁?
并且会调用构造函数

tx.origin: 0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
</code></pre>
<p>下面修改协议，对上面的数据进行一次重新测试</p>
<pre><code>    coinbase = block.coinbase();
    difficulty = block.difficulty();
    gaslimit = block.gaslimit();
    number = block.number();
    nottime = block.timestamp();
    calldata = msg.data();
    gas = msg.gas();
    sender = msg.sender();
    weivalue = msg.value();
</code></pre>
<p><img src="/img/solidity01.png" alt=""></p>
<h2>Solidity by Example</h2>
<p><strong>Voting</strong></p>
<p>how to assign voting rights to the correct persons and how to prevent manipulation.</p>
<pre><code>pragma solidity ^0.4.9;


contract Ballot {
// struct type
struct Voter{
    uint weight;
    bool voted;
    address delegate;
    uint vote;
}

struct Proposal{
    bytes32 name;
    uint voteCount;
}

address public chairperson;
mapping(address =&gt; Voter) public voters;
Proposal[] public proposals;


function Ballot(bytes32[] proposalNames) public {
    chairperson = msg.sender;
    voters[chairperson].weight =1;

    for(uint i=0;i&lt;proposalNames.length;i++)
    {
        proposals.push(Proposal({
            name: proposalNames[i],
            voteCount:0
    }));
    }
}
// Give `voter` the right to vote on this ballot.
// May only be called by `chairperson`.
function giveRightToVote(address voter) public {
    //If the arguments of 'require' evaluate to 'false'
    // it terminates and reverts all changes to
    // the state and to Ether balances. It is often
    // a good idea to use this functions are called incorrectly.proposals//
    // but watch out,this will currently also consume all provided gas
    //(this is planned to change in the future)
    require(
        (msg.sender == chairperson) &amp;&amp;
         !voters[voter].voted &amp;&amp; (voters[voter].weight ==0)
        );
    voters[voter].weight =1;
}

function delegate(address to) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);

    require(to != msg.sender);

    while( voters[to].delegate != address(0))
    {
        to = voters[to].delegate;
        require(to != msg.sender);
    }
    sender.voted = true;
    sender.delegate = to;
    Voter storage delegate_ = voters[to];
    if(delegate_.voted){
        proposals[delegate_.vote].voteCount += sender.weight;
    }else{
        delegate_.weight += sender.weight;
    }

}

function vote(uint proposal) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);
    sender.voted = true;
    sender.vote = proposal;

    proposals[proposal].voteCount += sender.weight;
}

function winningProposal() public view returns (uint winningProposal_)
{
    uint winningVoteCount =0;
    for(uint p=0; p&lt;proposals.length; p++)
    {
        if (proposals[p].voteCount &gt;winningVoteCount){
            winningVoteCount = proposals[p].voteCount;
            winningProposal_ =p;
        }
    }
}

function winnerName() public view returns (bytes32 winnerName_)
{
    winnerName_ = proposals[winningProposal()].name;
}
}

构造函数:
合约的构造者拥有 weight =1
候选人数组: name, 票数 0

giveRightToVote(address voter)
	赋予投票人的投票权利，首先保证合约的拥有者 是主席
	投票者 没有投过票， 权力是0，才能赋予投票权

delegate: 将自己的投票权限给代理人，让代理人帮助投票
	

协议稍微有点复杂，但还是看完了，里面有个问题
一: 测试的时候  [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]作为议案，供用户投票
二: giveRightToVote: 可以输入 1，2，3等值，作为voter账户，
初始化的时候会将bool初始化为false，uint为0，address 为0
三： delegate代理，这个代理的入参是address to，但是这个动作
的发起者是msg.sender,在测试的时候是和create的账户保持一致
的，作为A，然后to作为B，把A的投票权限让B去代理，那么最终的实
际操作在B中，但是也就意味着这样无法完成下面的vote操作，因为
vote操作需要的是msg.sender的投票权限，怎么才能切换用户或者
address，或者msg.sender从而实现不同用户的切换
</code></pre>
<h2>Blind Auction(暗箱拍卖)</h2>
<p>这是一个非公开的拍卖系统，在透明的平台运行非公开拍卖看起来是矛盾的，但是密码学可以做到这一点。</p>
<p>在拍卖期间，参与者把自己的出价加密发送给拍卖系统，除了自己，任何人不知道出价是多少。当拍卖结束，参与者把出价明文发给拍卖系统，系统用明文加密运算，跟之前发送的密文比对，一致的话说明出价跟之前一样，出价有效。</p>
<p>在传统领域，很多业务很容易产生暗箱操作，智能合约让参与者跟工作人员都无法干预系统，系统也没有人的行为，全部是自动执行的代码，使业务变得透明公平，这对产业的变革是颠覆性的。</p>
<h2>Lauout of a Solidity Source File</h2>
<p>pragma  0.x.0  x.0.0</p>
<pre><code>pragma solidity ^0.4.21
</code></pre>
<p>这样一个源文件将不会被低于0.4.0 的编译器编译，或者高于0.5.0 的编译器编译。^ 代表直到0.5.0 之前的编译器都可以编译</p>
<p>导入其他文件</p>
<pre><code>import &quot;filename&quot;;
import * as symbolName from &quot;filename&quot;;
</code></pre>
<p>Paths</p>
<p>注释</p>
<pre><code>pragma solidity ^0.4.0;

/** @title Shape calculator. */
contract shapeCalculator {
/** @dev Calculates a rectangle's surface and perimeter.
  * @param w Width of the rectangle.
  * @param h Height of the rectangle.
  * @return s The calculated surface.
  * @return p The calculated perimeter.
  */
function rectangle(uint w, uint h) returns (uint s, uint p) {
    s = w * h;
    p = 2 * (w + h);
}
}	
</code></pre>
<h2>Structure of a Contract</h2>
<p>State Variables</p>
<pre><code>uint storedData;  // state variable
</code></pre>
<p>Functions</p>
<pre><code>function bid() public payable // function
</code></pre>
<p>Function Modifiers</p>
<pre><code>函数修饰符可以用声明的方式修改函数的语义。

modifier onlySeller() // Modifier
</code></pre>
<p>Events</p>
<pre><code>event HighestBidIncreased(address bidder,uint amount) // Event
</code></pre>
<p>Struct Types</p>
<pre><code>struct Voter{
		uint weight;
		bool voted;
	}  // Struct
</code></pre>
<p>Enum Types //枚举</p>
<pre><code>enum State { Created,Locked,Inactive } // enum
</code></pre>
<h2>Types</h2>
<pre><code>bool: true/false  !, &amp;&amp;, ||, == ,!=
int/uint: uint--&gt; uint 256, int --&gt;int256
&lt;=, &lt; ==,!=,&gt;=, &gt;
位运算: &amp;，| ^ 
&lt;&lt; 左移，  &gt;&gt; 右移
</code></pre>
<p>address: 20 byte value</p>
<pre><code>Members of Addresses: balance and transfer
balance: 查询地址的余额
transfer: 发送Ether(wei 计数) 

address x = 0x123;
address myAddress = this;
if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 

send：
	使用send的时候有些危险，如果call stack depth是1024，或者接收者运行超出gas，交易失败。因此为了交易的安全，检查使用send的返回值； 使用transfer更安全: 或者使用一个方式 接收者撤回money

call,callcode,delegatecall
</code></pre>
<p>Fixed-size Bytes</p>
<pre><code>bytes1,bytes2,bytes3,....bytes32, byte 是bytes1的别名

it is possible to use n array of bytes as byte[], but
is is wasting a lot of space.,31 bytes every element, 
to be exact, when passing in calls, it is better to use bytes
</code></pre>
<p>Dynamically-sized byte array</p>
<pre><code>bytes: 是一个可变长的数组，不是一个value-type
string: 动态可变长的UTF-8编码的字符串。
</code></pre>
<p>Address Literals (地址常量)</p>
<p>Rational and Integer Literals</p>
<p>String Literals</p>
<p>Hexadecimal Literals</p>
<p>Enums</p>
<pre><code>	enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
	ActionChoices choice;
	ActionChoices constant defaultChoice = ActionChoices.GoStraight;
</code></pre>
<p>Function Types</p>
<pre><code>function (&lt;parameter types&gt;) {internal|external} [pure|constant|view|payable] [returns (&lt;return types&gt;)]

默认情况下，函数是内部的，因此，internal可以忽略

function f() public view returns (bytes4) {
	return this.f.selector;
}


//外部函数不能在内部调用
function Pyramid(uint l) public pure returns (uint){
    return ArrayUtils.range(l).map(square).reduce(sum);
}
function square(uint x) external pure returns (uint)
{
    return x*x;
}
function sum(uint x,uint y) external pure returns (uint)
{
    return x+y;
}
因此上面的句子编译失败
</code></pre>
<p>功能修饰符</p>
<pre><code>修饰符可用于轻松更改功能的行为，例如，可以在执行功能之前自动检查条件。修饰符是合同的可继承属性，可能会被派生合同覆盖。

//此合约仅定义修饰符，但不是用它 - 它将用于派生合约
//函数体插入其中，特殊符号 _; 在修饰符的定义出现。
//这意味着如果所有者调用此函数，则执行该函数，否则抛出异常。
modifier onlyOwner{
	require(msg.sender == owner; )
	-;
}
</code></pre>
<p>Reference Types （引用类型）</p>
<pre><code>因为变量间的复制开销比较大，因此一般可以考虑存储在memoey或者storage中

默认的 对于函数参数(包括返回值)是在memory中，本地变量是在storage中
state variables 强制被存储在storage中

还有第三个数据位置，calldata，是一个不能被修改的，不能被持久化的位置，并且函数参数被存储。函数参数被强制性的存储在calldata中。
</code></pre>
<p>数据位置非常重要，因为它们改变了赋值的行为：存储和内存之间的赋值以及状态变量（甚至来自其他状态变量）总是创建一个独立的副本。对本地存储变量的赋值只分配一个引用，而这个引用总是指向状态变量，即使后者在这期间也被改变了。另一方面，从内存存储引用类型到另一个内存存储引用类型的赋值不会创建副本。</p>
<pre><code>uint[] x; // 本地变量存储在storage中
function f(uint[] memorArray)： 函数参数保存在memory中
x=memoryArray; 复制一份memory中的数据到storage中。

var y=x;// 本地变量的赋值是分配一个指向storage的引用
y.length=2; //通过修改引用的大小类修改实际存储对象
delete x;  修改storage中的数据
y=memoryArray; // 不能给一个指针变量赋值一个memory变量。
</code></pre>
<h2>分析</h2>
<p>局部变量是函数中声明的变量，状态变量是合约内声明的共有变量</p>
<p>1 storage 转换为storage</p>
<pre><code>当把一个storage类型的变量赋值给另一个storage时，只是修改了指针
S s; // storage
funciton convertToStorage(S storage s) internal{
	S tmp =s;  // storage  --&gt; storage
	tmp a =&quot;Test&quot;;
}
function call() returns (string)
{
	convertToStorage(s);
	return s.a;//  Test
}
将传入的storage变量，赋值给另一个storage变量，并修改值，最后发现合约的状态变量s也被改变了， 引用的作用
</code></pre>
<p>memory转换为storage</p>
<pre><code>因为局部变来那个和状态变量的类型都可能是storage，分开来讲
</code></pre>
<p>memory赋值给状态变量(原来memory的值是直接可以拷贝给storage的状态变量的，而不能拷贝给局部变量)</p>
<pre><code>将一个memory类型的变量赋值给一个状态变量时，实际上是将内存变量拷贝到存储中

S s;  // storage
function call() returns(string){
	S memry tmp = S(&quot;memory&quot;,0);
	memoryToState(tmp);
	return s.a;
}
function memoryToState(S memory tmp) internal{
	s= tmp;
	tmp.a =&quot;Test&quot;;
}
memory --&gt; 状态变量，是值拷贝
</code></pre>
<p>memory赋值给局部变量</p>
<pre><code>由于在区块链中，storage必须是静态分配存储空间的。局部变量虽然是一个storage的，但是仅仅是一个storage类型的指针。如果进行这样的赋值，会产生错误。

S tmp=s;  是错误的
</code></pre>
<p>storage到memory， 也是值的拷贝，注意storage到memory只需要强制定义左边的类型， 是可以转换成功的。</p>
<p>memory 到memory: memory 之间是引用传递，不是值传递</p>
<p>Arrays</p>
<pre><code>bytes 和string 是特殊的数组，bytes和byte[] 比较详细，但是是稠密的。
</code></pre>
<p>将数组保存在Memory中</p>
<pre><code>将数组变量保存在内存中可以使用new关键字，和保存在storage中相比，不能通过.length 重新划分memory数组长度
</code></pre>
<p>Array Literals/Inline Arrays</p>
<pre><code>数组常量 作为一个表达式 并且不需要马上赋值
function g(uint[3] _data) public pure{
}
则传入参数的形式是
g([uint(1),2,3]);
数组常量是一个memory数组，长度固定，基本类型是给定数据的普遍类型，[1,2,3]是uint8[3] memory,因为每一个元素的类型是uint8,因此，需要将第一个类型转换为uint。注意，固定长度的memory数组不能被分配给动态长度的memory数组。

也就是说 uint[] x= [uint(1),3,4]是不行的，后面的是固定长度的，前面的是可变长度的。uint[] x 是一个storage变量。

uint[] memory  x=new uint[](3)
 x = [uint(3),3,4]
Type uint256[3] memory is not implicitly convertible to expected type uint256[] memory.
后面的是固定长度的数组，前面的是可变长的数组，不能赋值?
有点奇怪
</code></pre>
<p>Members</p>
<pre><code>length: 动态数组可以在storage(不是在memory)中调整大小通过.length 

那么动态数组应该如何定义呢?
uint[] x = new uint[](4)
TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] storage pointer

push: 动态stoeage 数组和bytes 有一个函数push，可以用来追加一个新的元素在数组的末尾。 函数返回一个新的长度
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/12/区块链01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/区块链01/" itemprop="url">区块链01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T13:06:57+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Windows</h2>
<p><a href="https://github.com/ethereum/go-ethereum/releases/" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/</a></p>
<p>安装后用cmd命令打开命令行，进入到你安装geth的目录下，输入geth –help 命令，如果输出一大堆关于geth的信息如下图则说明安装成功。当前geth命令只能在geth对应的目录下使用，如果想要在任何目录使用geth命令，只要把你安装geth的目录的路径加入到系统环境环境变量path中即可。</p>
<p><a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11</a></p>
<p><a href="https://ethereum.github.io/go-ethereum/downloads/" target="_blank" rel="noopener">https://ethereum.github.io/go-ethereum/downloads/</a>
最全的下载地址</p>
<p>创世文件的定义
<a href="https://my.oschina.net/stevex/blog/746669" target="_blank" rel="noopener">https://my.oschina.net/stevex/blog/746669</a></p>
<p>geth --identity &quot;PICC&quot; --rpc --rpccorsdomain &quot;*&quot;  --datadir &quot;%cd%\chain&quot;  --port &quot;30303&quot; --rpcapi &quot;db,eth,net,web3&quot;  --networkid 95518 console</p>
<p>targetgaslimit –每个块的gas上限，这里可以暂时理解为容量 rpc –启动rpc通信，可以进行智能合约的部署和调试 rpcaddr –rpc接口的地址 rpcport –rpc接口的端口号 port –网络监听端口，用于节点之间通信 rpcapi –设置rpc的范围，暂时开启eth,web3,personal足够 networkid –设置当前区块链的网络ID，是一个数字，可以随便写 identity –区块链的标示，随便填写，用于标示目前网络的名字 nodiscover 禁止被网络中其它节点发现，需要手动添加该节点到网络 maxpeers 最大节点数量 datadir –设置当前区块链网络数据存放的位置 unlock –解锁某用户（此处用用户坐标来控制，解锁后的用户调用接口发起交易时，不要需要提供密码） rpccorsdomain 限制rpc访问源的ip，代表不限制 mine 允许挖矿 console –启动命令行模式，可以在Geth中执行命令*</p>
<p>personal.newAccount()</p>
<h2>智能合约</h2>
<p>以太坊很大的特色就是能够实现智能合约，所谓智能合约，是密码学家提出以数字形式定义的一系列承诺，包括合约参与方可以在上面执行这些承诺的协议。</p>
<p>智能合约一旦设立指定后，能够无需中介的参与自动执行，并且没有人可以阻止它的运行。</p>
<p>区块链为智能合约提供可行执行环境，智能合约为区块链扩展应用。而在以太坊上的智能合约，能够控制区块链上各种数字资产进行复杂的操作，随着智能合约开始获得越来越多的使用，人们也发现，就像现实世界的合同一样，如果没有认真审核的话，其中就有可能出现漏洞，并且被坏人利用。</p>
<p><strong>智能合约是什么</strong></p>
<p>从用户角度来讲，智能合约通常被认为是一个自动担保账户，例如，当特定的条件满足时，程序就会释放和转移资金</p>
<p>从技术角度来讲，智能合约被认为是网络服务器，只是这些服务器并不是使用IP地址假设在互联网上，而是架设在区块链上，从而可以在上面运行特定的程序。</p>
<p>但与网络服务器不同的是，所有人都可以看到智能合约，因为这些智能合约的代码和状态都在区块链上。而且，与网络服务器不同的是，智能合约不依赖某个特定的硬件设备，事实上，智能合约的代码由所有参与挖矿的设备来执行</p>
<p>代码的执行是自动的: 要么成功执行，或者所有的状态变化都撤销(包括从当前失败的合约中已经发送或接受的信息) 这很重要，避免了合约 部分执行的情况(例如，在证券购买交易中，证券所有者已经转移发送了证券，但是密码学货币的支付转移却失败了)。 在区块链环境下，这尤为重要，因为没有办法来撤销执行错误所带来的不好的后果(如果对手不配合的话，根本没有办法逆转交易)</p>
<p>智能合约基于区块链的智能合约包括事务处理和保存的机制，以及一个完备的状态机，用于接受和处理各种智能合约；并且事务的保存和状态处理都在区块链上完成。事务主要包含需要发送的数据；而事件则是对这些数据的描述信息。事务及事件信息传入智能合约后，合约资源集合中的资源状态会被更新，进而触发智能合约进行状态机判断。如果自动状态集中某个或某几个动作的触发条件满足，则由状态机根据预设信息选择合约动作自动执行。</p>
<p>基于区块链的智能合约的构建及执行分为如下步骤：</p>
<p>智能合约的构建: 由区块链内的多个用户共同参与指定一份智能合约；</p>
<p>智能合约的存储: 智能合约通过P2P网络扩散到每个节点，并存入区块链</p>
<p>智能合约的执行: 智能合约定期进行自动机状态检查，将满足条件的事务进行验证，达成共识后自动执行并通知用户</p>
<p>智能合约其实就是一种可以自动化执行的简单交易。</p>
<p>https://www.cnblogs.com/fengzhiwu/p/5629468.html</p>
<h2>MetaMask过程</h2>
<h2>Ubuntu上</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/08/Spark-调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Spark-调优/" itemprop="url">Spark 调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-08T17:34:19+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Spark 性能调优记录</h2>
<p>Spark 性能调优要点分析</p>
<pre><code>并行度
压缩
序列化
数据倾斜
JVM调优(JVM数据结构化优化)
内存调优
Task性能调优(包含Mapper和Reducer两种类型的Task)
Shuffle网络优化(小文件合并)
RDD算子优化(RDD复用，自定义RDD)
数据本地性
容错调优
参数调优
</code></pre>
<p>大数据最怕的就是数据本地性和数据倾斜，调优Spark的重点一定是在数据本地性和数据倾斜入手</p>
<pre><code>资源分配和使用: 能够申请多少资源以及如何最优化的使用计算资源
Shuffle调优: 分布式系统必然面临的杀手级别的问题
数据倾斜： 分布式系统业务本身有数据倾斜
</code></pre>
<p>核心调优参数如下</p>
<pre><code>num-executors: 
	Yarn会按照Driver的申请去最终为当前的Application生产指定个数的Executors，
executor-memory:
	定义了每个Executor的内存，与JVM OOM密切相关，许多时候甚至决定了Spark运行的性能
	如果executor-memory超过了worker-memory 就会停止任务
	

executor-cores:
	决定了在Executors中能够并行执行的Tasks的个数

total-executor-cores:
	所有的core的个数，该数目除以executor-cores = executor个数


driver-memory: 默认是1G
spark.default.parallelize: 并行度问题，如果不设置这个参数，Spark会根据HDFS中的Block的个数去设置这一个数量，原理是每个Block对应一个Task，Spark官方的建议是每一个Core负责2-3个Task

spark.storage.memoryFraction: 默认占用60%，如果计算比较依赖历史数据则可以调高该参数，如果计算比较依赖Shuffle的话则需要降低该比例。

spark.shuffle.memoryFraction: 默认占用20%,如果计算比较依赖shuffle的话则需要调高该比例。
</code></pre>
<p>**Spark 更高性能的算子 **</p>
<p>Shuffle分开两部分，一个是Mapper端的Shuffle，另一个就是Reduce端的Shuffle，性能调优有一个很重要的总结就是尽量不使用Shuffle类的算子，能避免就尽量避免，因为一般进行Shuffle的时候，会把集群中多个节点上的同一个key汇聚在同一个节点上，例如reduceByKey。然后会优先把数据放在内存中，但如果内存不够的话会放在磁盘上。Shuffle在进行数据转去之前，为了整个集群的稳定性，它的Mapper端会把数据写到本地文件系统。这可能导致大量磁盘文件的操作。如何避免Shuffle可以考虑如下:</p>
<pre><code>1 采用Map端的Join(RDD1+RDD2) 先把一个RDD1的数据收集起来，然后再通过sc.broadcast()把数据广播到Executor上
2 如果无法避免Shuffle，退而求其次就是需要更多的机器参与Shuffle过程，这个时候就需要充分的利用Mapper端和Reducer端机制的计算资源，尽量使用Mapper端的Aggregate功能，例如aggregateByKey操作。相对于groupByKey而言，更倾向于使用reduceByKey() 和aggregateByKey() 来取代groupByKey(),因为groupbyKey() 不会进行Mapper端的操作，aggregateByKey()可以给予更多的控制。
3 如果一批一批的处理数据来说，可以使用mapPartitions(),但这个算子可能会出现OOM机会，会进行JVM的GC操作。
4 如果进行批量插入数据到数据库的话，建议使用foreachPartition() 
5 
6 官方建议使用repartitionAndSortWithPartitions()
7 数据进行复用时一般都会进行持久化persist()
8 
</code></pre>
<p>Spark开发调优</p>
<p>1 避免创建重复的RDD</p>
<pre><code>对于同一份数据，只应该创建一个RDD，不能创建多个RDD来代表同一份数据
</code></pre>
<p>2 尽可能复用同一个RDD</p>
<pre><code>由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
JavaRDD&lt;String&gt; rdd2 = rdd1.map(...)

rdd1.reduceByKey(...)
rdd2.map(...)

// 上面这个case中，其实rdd1和rdd2的区别无非就是数据格式不同而已，rdd2的数据完全就是rdd1 的子集而已，却创建了两个rdd
可以用一个rdd来执行操作

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
rdd1.reduceByKey(...)
rdd1.map(tuple._2...)
</code></pre>
<p>三: 对多次使用的RDD进行持久化</p>
<pre><code>Spark中对于一个RDD执行多次算子的默认原理是这样的：每次你对一个RDD执行一个算子操作时，都会重新从源头处计算一遍，计算出那个RDD来，然后再对这个RDD执行你的算子操作。这种方式的性能是很差的。

因此对于这种情况，我们的建议是：对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略，将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时，都会直接从内存或磁盘中提取持久化的RDD数据，然后执行算子，而不会从源头处重新计算一遍这个RDD，再执行算子操作。

val rdd1 = sc.textFile(&quot;hdfs://192.168.0.1:9000/hello.txt&quot;).cache()
rdd1.map(...)
rdd1.reduce(...)
</code></pre>
<p>四: 尽量避免使用Shuffle类算子</p>
<pre><code>Shuffle过程中，会发生大量的磁盘文件读写的IO操作，以及数据的网络传输操作。磁盘IO和网络传输也是Shuffle性能较差的主要原因。

// 传统的join操作会导致Shuffle操作
因为在两个RDD中，相同的Key都需要通过网络拉取到一个节点上，由一个task进行join操作。
val rdd3= rdd1.join(rdd2)

// Boradcast + map 的join操作，不会导致shuffle操作
//使用broadcast将一个数据量较小的rdd作为广播变量
val rdd2Data = rdd2.collect()
val rdd2DataBroadCast = sc.broadcast(rdd2Data)
</code></pre>
<p>五: 使用map-side预聚合的shuffle操作</p>
<pre><code>map-side端的操作: 类似于Mapreduce中的本地combiner
map-side 预聚合之后，每个节点就会只有一条相同的key?

建议使用reduceByKey或aggregateByKey算子来替代掉groupByKey算子。因为reduceByKey和aggregateByKey算子都会使用用户自定义的函数对每个节点本地相同的key进行预聚合，而groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间进行分发和传输，性能相对来说会比较差。
</code></pre>
<p><img src="/img/spark1.png" alt="">
<img src="/img/spark2.png" alt=""></p>
<p>六 使用高性能的算子</p>
<pre><code>1 使用groupByKey 替代groupByKey
2 使用mapPartitions 替代普通的map
mapPartitions 类的算子，一次函数调用会处理一个partition所有的数据，而不是一次函数调用处理一条，性能相对来说会高一些。但是有的时候，使用mapPartitions会出现OOM的问题。因为单次函数调用就要处理掉一个partition所有的数据，如果内存不够，垃圾回收时是无法回收掉太多对象的，很可能出现oom异常，所以使用这类操作要慎重。

3 使用foreachParitions替代foreach
也是一次函数调用处理一个partition的所有数据，而不是一条数据。 

实践中发现，


4 使用filter之后进行coalesce操作
通常对一个RDD执行filter算子过滤掉RDD中较多数据后(比如过滤掉30%以上的数据)，建议使用coalesce算子，手动减少RDD的partition数量，将RDD中的数据压缩到更少的partition中去。


5 使用repartitionAndSortWithinPartition替代repartition与sort算子

repartitionAndSortWithinPartitions是Spark官网推荐的一个算子，官方建议，如果需要在repartition重分区之后，还要进行排序，建议直接使用repartitionAndSortWithinPartitions算子。因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。
</code></pre>
<p>七: 广播大变量</p>
<pre><code>在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。

因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。

通过广播方式，将变量的位置从 task 放在了Executor中
用以共享变量
</code></pre>
<p>使用Kryo优化序列化性能</p>
<pre><code>* 在算子函数中使用外部变量时，该变量会被序列化后进行网络传输
* 将自定义的类型作为RDD的泛型类型时(比如JavaRDD，Student是自定义类型)，所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口
* 使用可序列化的持久化策略时，Spark会将RDD中的每个partition都序列化成一个大的字节数组

官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。


// 创建SparkConf对象。
val conf = new SparkConf().setMaster(...).setAppName(...)
// 设置序列化器为KryoSerializer。
conf.set(&quot;spark.serializer&quot;, &quot;org.apache.spark.serializer.KryoSerializer&quot;)
// 注册要序列化的自定义类型。
conf.registerKryoClasses(Array(classOf[MyClass1], classOf[MyClass2]))
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/08/Spark-Deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Spark-Deploy/" itemprop="url">Spark Deploy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-08T13:35:04+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Cluster Mode Overview</h2>
<p>Read through the <a href="http://spark.apache.org/docs/2.3.0/submitting-applications.html" target="_blank" rel="noopener">application submission guide</a> to learn about launching applications on a cluster</p>
<p><strong>Components</strong></p>
<p>Spark 应用在集群上作为独立的进程组来运行，在您的 main 程序中通过 SparkContext 来协调（称之为 driver 程序）。</p>
<p>具体的说，为了运行在集群上，SparkContext 可以连接至几种类型的 Cluster Manager（既可以用 Spark 自己的 Standlone Cluster Manager，或者 Mesos，也可以使用 YARN），它们会分配应用的资源。一旦连接上，Spark 获得集群中节点上的 Executor，这些进程可以运行计算并且为您的应用存储数据。接下来，它将发送您的应用代码（通过 JAR 或者 Python 文件定义传递给 SparkContext）至 Executor。最终，SparkContext 将发送 Task 到 Executor 以运行。</p>
<p><img src="http://spark.apache.org/docs/2.3.0/img/cluster-overview.png" alt=""></p>
<p>这里有几个需要注意的地方</p>
<ol>
<li>每个application获取到executor进程，会保持在应用的生命周期中并期望在多个线程中运行Task。在调度方面和Executor方面隔离。</li>
<li>Spark不知道底层的Cluster Manager到底是什么类型的。 只要获得Executor进程，并且彼此之间通信</li>
</ol>
<p><strong>Cluster Manager类型</strong></p>
<ul>
<li>Standalone: Spark中使得更容易来安装集群的一个简单的Cluster Manager</li>
<li>Mesos: 一个通用的Cluster Manager，可以运行Hadoop Mapredce和其他服务应用</li>
<li>Hadoop YARN: Hadoop 2的ResourceManager</li>
<li>Kubernetes – an open-source system for automating deployment, scaling, and management of containerized applications.</li>
</ul>
<p>** 提交应用 **
使用spark-submit 脚本可以提交应用程序至任何类型的集群，在 <a href="http://spark.apache.org/docs/2.3.0/submitting-applications.html" target="_blank" rel="noopener">application submitting</a>可以获得详细信息。</p>
<p>**监控 **</p>
<p>每个 driver 程序有一个 Web UI，通常在端口 4040 上，它展示了关于运行 task，executor，和存储使用情况的信息。在网页浏览器中访问这个 UI : http://&lt;driver-node&gt;:4040。<a href="http://spark.apache.org/docs/2.3.0/monitoring.html" target="_blank" rel="noopener">监控指南</a> 也描述了其它的监控选项。</p>
<p><strong>Job调度</strong></p>
<p>Spark既可以在应用间(Cluster Manager级别)，也可以在应用内(如果一个application中发生多个计算) 调度资源。<a href="http://spark.apache.org/docs/2.3.0/job-scheduling.html" target="_blank" rel="noopener">job scheduling overview</a></p>
<h2>Spark Standalone Mode</h2>
<p>安装过程</p>
<pre><code>1 解压: tar
2 local模式: 直接使用
3 Standalone模式:
	mv spark-env.sh.template  spark-env.sh
	export JAVA_HOME=/usr/lib/jdk
	export SPARK_MASTER_IP=cd-bigdata02

4 slaves
	cd-bigdata02
	cd-bigdata03
</code></pre>
<p>启动之后:</p>
<p><img src="/img/spark0.png" alt=""></p>
<pre><code>cores是worker的逻辑cpu个数
cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l
分别是4 和 8
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/02/scrapy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/scrapy/" itemprop="url">scrapy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-02T10:01:50+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Scrapy</h2>
<p>测试网址
<a href="http://quotes.toscrape.com/page/1/" target="_blank" rel="noopener">http://quotes.toscrape.com/page/1/</a></p>
<p>def start_requests(self):</p>
<pre><code>must return an iterable of Requests(you can return a 
list of requests of write a generator function) which 
Spider will  begin to crawl from. Subsequent requests 
will be generated successively form these initial 
requests
</code></pre>
<p>parse()</p>
<pre><code>The response parameter is an instance of TextResponse 
that holds the page content and has further helpful 
methods to handle it 
</code></pre>
<p>The parse() method usually parses the response, extracting the scraped data as dicts and also finding new URLs to follow and creating new requests (Request) from them.</p>
<p><strong>How to run our spider</strong></p>
<pre><code>scrapy crawl quotes

&gt;&gt;&gt; response.css('title')
[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;Quotes to Scrape&lt;/title&gt;'&gt;]

response.css('title') is a list-like called SelectorList, which represents a list of selector objects that wrap around XML/HTML elements and allow you to run further queries to fine-grain the seletion or extract the data.
</code></pre>
<h2>Using Selectors</h2>
<pre><code>https://doc.scrapy.org/en/latest/_static/selectors-sample1.html
&gt;&gt;&gt; response.xpath('//title/text()')
[&lt;Selector (text) xpath=//title/text()&gt;]
&gt;&gt;&gt; response.css('title::text')
[&lt;Selector (text) xpath=//title/text()&gt;]

response.css('img')

[&lt;Selector xpath='descendant-or-self::img' data='&lt;img src=&quot;image1_thumb.jpg&quot;&gt;'&gt;,
&lt;Selector xpath='descendant-or-self::img' data='&lt;img src=&quot;image2_thumb.jpg&quot;&gt;'&gt;,
&lt;Selector xpath='descendant-or-self::img' data='&lt;img src=&quot;image3_thumb.jpg&quot;&gt;'&gt;,
&lt;Selector xpath='descendant-or-self::img' data='&lt;img src=&quot;image4_thumb.jpg&quot;&gt;'&gt;,
&lt;Selector xpath='descendant-or-self::img' data='&lt;img src=&quot;image5_thumb.jpg&quot;&gt;'&gt;]


&gt;&gt;&gt; response.css('img').xpath('@src').extract()
[u'image1_thumb.jpg',
u'image2_thumb.jpg',
u'image3_thumb.jpg',
u'image4_thumb.jpg',
u'image5_thumb.jpg']


说明xpath中里面的某一个属性用 @xxx 来表示



&gt;&gt;&gt; response.xpath('//base/@href').extract()
[u'http://example.com/']

&gt;&gt;&gt; response.css('base::attr(href)').extract()
[u'http://example.com/']

&gt;&gt;&gt; response.xpath('//a[contains(@href, &quot;image&quot;)]/@href').extract()
[u'image1.html',
u'image2.html',
u'image3.html',
u'image4.html',
u'image5.html']

&gt;&gt;&gt; response.css('a[href*=image]::attr(href)').extract()
[u'image1.html',
u'image2.html',
u'image3.html',
u'image4.html',
u'image5.html']

&gt;&gt;&gt; response.xpath('//a[contains(@href, &quot;image&quot;)]/img/@src').extract()
[u'image1_thumb.jpg',
u'image2_thumb.jpg',
u'image3_thumb.jpg',
u'image4_thumb.jpg',
u'image5_thumb.jpg']

&gt;&gt;&gt; response.css('a[href*=image] img::attr(src)').extract()
[u'image1_thumb.jpg',
u'image2_thumb.jpg',
u'image3_thumb.jpg',
u'image4_thumb.jpg',
u'image5_thumb.jpg']
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/01/hadoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/hadoop/" itemprop="url">hadoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-01T13:39:05+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>hadoop的集群是基于master/slave模式，namenode和jobtracker属于master，datanode和tasktracker属于slave，master只有一个，而slave有多个.</p>
<p>SecondaryNameNode内存需求和NameNode在一个数量级上，所以通常secondary NameNode（运行在单独的物理机器上）和 NameNode 运行在不同的机器上。</p>
<p>JobTracker对应于NameNode,TaskTracker对应于DataNode.</p>
<p>DataNode和NameNode是针对数据存放来而言的.JobTracker和TaskTracker是对于MapReduce执行而言的.</p>
<p>mapreduce中几个主要概念，mapreduce 整体上可以分为这么几条执行线索：</p>
<p>jobclient，JobTracker与TaskTracker。</p>
<p>1、JobClient会在用户端通过JobClient类将已经配置参数打包成jar文件的应用存储到hdfs，并把路径提交到Jobtracker,然后由JobTracker创建每一个Task（即 MapTask 和 ReduceTask） 并将它们分发到各个TaskTracker服务中去执行。</p>
<p>2、JobTracker是一master服务，软件启动之后JobTracker接收Job，负责调度Job的每一个子任务。task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。一般情况应该把JobTracker 部署在单独的机器上。</p>
<p>3、TaskTracker是运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信，接收作业，并负责直接执行每一个任务。 TaskTracker 都需要运行在HDFS的DataNode上。</p>
<p>secondaryNameNode: 他的目的使帮助 NameNode 合并编辑日志，减少 NameNode 启动时间</p>
<p>列决几个Hadoop生态圈的组件并作简要概述
Zookeeper:是一个开源的分布式应用程序协调服务,基于zookeeper可以实现同步服务，配置维护，命名服务。</p>
<p>Flume:一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。</p>
<p>Hbase:是一个分布式的、面向列的开源数据库, 利用Hadoop HDFS作为其存储系统.</p>
<p>Hive:基于Hadoop的一个数据仓库工具，可以将结构化的数据档映射为一张数据库表，并提供简单的sql 查询功能，可以将sql语句转换为MapReduce任务进行运行。</p>
<p>Sqoop:将一个关系型数据库中的数据导进到Hadoop的 HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p>
<p>4 正常工作的Hadoop集群中Hadoop都分别需要启动哪些进程，它们的作用分别是什么?</p>
<p>a) NameNode 是hadoop中的主服务器，管理文件系统名称空间和对集群中存储的文件的访问，保存有metadate</p>
<p>b) SecondaryNameNode 不是NameNode的冗余守护进程，而是提供周期检查点检查点和清理服务。帮助NN合并edits log,减少NN启动时间</p>
<p>c) DataNode 负责管理连接到节点的存储(一个集群中可以有多个节点)。 每个存储数据的节点运行一个datanode守护进程。</p>
<p>d) ResourceManager(JobTracker),负责调度DataNode上的工作。每个DataNode有一个TaskTracker，执行实际工作。</p>
<p>e) NodeManager (TaskTracker)执行任务</p>
<p>4 HDFS 的存储机制是什么</p>
<p>客户端通过把请求发送给NameNode active，NN会把文件切成1到N个固定大小的block(一般默认为128M)并上传到DataNode中。当所有block拷贝结束时，NN会立即通知客户端上传结果。但此时上传的流程还未结束。DN还需要根据配置信息的副本数量，在不同的机架节点上通过局域网做数据拷贝工作。</p>
<p>5 Hadoop中的job和task之间的区别是什么</p>
<p>JobTracker是一个master服务，软件启动之后，JobTracker接受Job，负责调度Job的每一个子任务task运行于TaskTracker上，并监控他们，如果发现有失败的task就重新运行它。一般情况应该把JobTracker部署在单独的机器上。</p>
<p>TaskTracker是运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信，接收作业，并负责执行每一个任务</p>
<p>7 如何决定一个job的map和reduce的数量</p>
<pre><code>splitSize = max{minSize,min{maxSize,blockSize}}
map的数量由处理的初级分成的block熟练决定，= total_size/split_size
reduce的数量job.setNumReduceTasks(x);x 为reduce的数量
</code></pre>
<p>8 如何为一个Hadoop任务设置mappers的数量</p>
<p>InputFormat在默认情况下会根据hadoop集群HDFS块大小进行分片，每一个分片会由一个map任务来进行处理，当然用户还是可以通过参数mapred.min.split.size 参数在作业提交客户端进行自定义设置。还有一个重要参数就是mapred.map.tasks, 这个参数设置的map数量仅仅是一个提示，只有当InputFormat决定了map任务的个数比mapred.map.tasks值小时才起作用。同样，Map任务的个数也能通过使用JobConf的conf.setNumMapTasks()来手动的设置。这个方法能够用来增加map任务的个数，但是不鞥设定任务的个数小于Hadoop系统通过分隔输入数据得到的值。</p>
<p>9 如何为一个Hadoop任务设置要创建的reducer的数量</p>
<p>纯粹的mapreduce task的reduce task数很简单，就是参数mapred.reduce.tasks 的值</p>
<p>10 MapReduce 中排序发生的几个阶段</p>
<p>4个阶段</p>
<p>Splitting: 在进行map计算之前，mapreduce会根据输入文件计算输入分片(inputsplit),每个输入分片针对一个map任务。输入分片存储的并非数据本身，</p>
<p>11 请描述Mapreduce中shuffle阶段的工作流程，如何优化shuffle阶段</p>
<p>分区，排序，溢写，拷贝到对应reduce机器上，增加conbiner，压缩溢写的文件。</p>
<p>12 Mapreduce中combiner的作用是什么，一般使用情景，哪些情况不需要？</p>
<p>MR作业中的Map阶段会输出结果数据到磁盘中</p>
<p>Combiner只适应于那种reduce的输入类型完全一直，且不影响最终结果的场景，比如累加，最大值等。也可以用于过滤数据，在map端将无效的数据过滤到</p>
<p>combiner的作用就是在map端对输出先做一次合并，以减少传输到reducer的数据量</p>
<p>combiner最基本是实现本地key的归并，具有类似本地reduce，那么所有的结果都是reduce</p>
<p>使用combiner，先完成的map会在本地聚合，提升速度。</p>
<pre><code>map--&gt; 本地reduce --&gt;集群reduce
</code></pre>
<p>13  如果没有定义partitioner，那数据在被送达reducer前是如何被分区的</p>
<pre><code>如果没有自定义的partitioning，则默认的partition算法，即根据每一条数据的key的hascode 值 取模reduce的数量，得到的数字就是reducer 分区号
</code></pre>
<p>14 Map阶段结束后，Hadoop框架会处理：Partitioning，shuffle和sort，</p>
<pre><code>map task上的shuffle结束，此时reduce task 上的shuffle开始，抓取fetch所属于自己分区的数据，同时将这些分区的数据进行排序sort(默认的排序是根据每一条数据的键的字典排序)，进而将数据进行合并merge，即根据key相同的，将其value组成一个集合，最后输出结果。
</code></pre>
<p>15 一个mr作业跑得比较慢，如何来优化，</p>
<pre><code>数据倾斜
	数据倾斜可能是partition不合理，导致部分partition中的数据过多，部分过少，通过分析数据，自定义分区解决。

合理设置map和reduce数: 两个都不能设置太少，也不能设置太多。太少，会导致task等待，延长处理时间；太多，会导致map，reduce任务间竞争资源，造成处理超时等错误。

设置map，reduce共存: 调整slowstart.completedmaps参数，是map运行到一定程度后，reduce也开始运行，减少reduce的等待时间。

合并小文件: 在执行mr任务前将小文件进行合并，大量的小文件会产生大量的map任务，增大map任务装载次数，而任务的装载比较耗时，从而导致mr运行较慢

减少spill次数
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/01/mysql-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/mysql-基础/" itemprop="url">mysql 基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-01T09:32:45+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/02/26/CKY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/26/CKY/" itemprop="url">CKY</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T16:13:38+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>CKY(Cocke-Kasami-Younger) and Earley Parsing Algorithms</h2>
<p><strong>Context Free Grammar</strong></p>
<p>A Context-free Grammar(CFG) is a 4-tuple:
$$G={N,\sum  ,P,S}$$</p>
<p><img src="/img/nlp_cky1.png" alt=""></p>
<p><strong>Chomsky Normal Form 乔姆斯基范式</strong></p>
<p>A context-free grammar</p>
<pre><code>A--&gt; \alpha
A--&gt; BC
Any CFG can be converted a weakly equivalent grammar in CNF
</code></pre>
<h2>Parsing Algorithm</h2>
<pre><code>CFGs are basis for describing(syntactic) structure of NL sentences
Thus- Parsing Algorithms are core of NL analysis systems
Recognition vs. Parsing:
	Recognition-deciding the membership in the language
	Parsing- Recogintion+producing a parse tree for it
Parsing is more difficult than recogintion(time complexity)
Ambiguity - an input may have exponentially many parses.
</code></pre>
<h2>Parsing Algorithms</h2>
<pre><code>Top-down vs bottom-up
Top-down:(goal-driven): from the start symbol down
Bottom-up:(data-driven): from the symbols up.

Naive vs. dynamic programming
Naive: enumerate everything
backtracking: try something, discard partial solutions.
Dynamic programming: save partial solutions in a table

Example:
CKY: bottom-up dynamic programming
Earley parsing: top-down dynamic programming.
</code></pre>
<h2>CKY</h2>
<pre><code>one of the earliest recogintion and parsing algorithms 
The standard version of CKY can only recoginze languages defined by context-free grammars in Chomsky Normal Form(CNF)
It is also possible to extend the CKY algorithm to handle some grammars which are not in CNF
	Harder to understand
Based on a &quot;dynamic programming&quot; approach:
	Build solutions compositionally from sub-solutions
Uses the grammar directly
</code></pre>
<p>Considers every possible consective(连续的，连贯的) subsequence of letters and sets $k \in T[i,j]$, if the sequence of letters starting frm i to j can be generated from the non-terminal K.</p>
<p>Once it has considered sequences of length 1 , it goes on to sequences of length 2,and so on</p>
<p>For subsequences of length 2 and greater, it considers every possible partition of the subsequence into two halves, and checks to see if there is some production A-&gt;BC sunch that B matches the first half and C matches the second half. If so, it records A as matching the whole subsequence.</p>
<p>Once this process if completed, that sentence if recognnized by the grammar if the entire string is matched by the start symbol.</p>
<p>**Observation: ** any portion of the input string spanning i to j can be split at k, and structure can then be built using sub-solutions spanning i to k and sub-solitions spanning k to j.</p>
<p>**Meaning: ** Solution to problem [i,j] can constructed from solution to sub problem[i,k] and solution to sub problem [k,j]</p>
<p><img src="/img/nlp_cky2.png" alt=""></p>
<p><img src="/img/nlp_cky3.png" alt=""></p>
<p>The algorithm is &quot;bottom-up&quot; in that we start with bottom of derivation tree.</p>
<p><img src="/img/nlp_cky4.png" alt=""></p>
<h2>The CKY Algorithm</h2>
<pre><code>function CKY(word w,grammar P) returns table
for i&lt;- from 1 to length(w) do
	table[i-1,i] &lt;- {A| A-&gt;wi in P}
for j &lt;- from 2 to length(w) do
	for i &lt;- form j-2 down to 0 do
		for k &lt;- i+1 to j-1 do
			table[i,j] &lt;- table[i,j] 并 {A|A-&gt; BC in P,B in table[i,k],C in table[k,j]}
</code></pre>
<p><img src="/img/nlp_cky5.png" alt=""></p>
<p>这种解析过程能够判断出句子的形式</p>
<h2>Parsing results</h2>
<pre><code>We keep the results for every wij in a table
Note that we only need to fill in entries up to the diagonal
Every entry in the table T[i,j] can contains up to r=|N| symbols (the size of non-terminal set)
We can use lists or a Boolean n*n*r table
We then want to find T[0,b,S] = true
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JackNiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackNiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
