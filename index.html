<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SpeechAndLanguageProcessing">
<meta property="og:url" content="http://niuwenchen.github.io/index.html">
<meta property="og:site_name" content="SpeechAndLanguageProcessing">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpeechAndLanguageProcessing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://niuwenchen.github.io/"/>





  <title>SpeechAndLanguageProcessing</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SpeechAndLanguageProcessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">translate and learning language model</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/27/数据仓库基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/数据仓库基本概念/" itemprop="url">数据仓库基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T09:18:36+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>数据仓库与数据挖掘概述</h2>
<p>1 必背</p>
<pre><code>数据仓库是面向主题的、集成的、稳定的、不同时间的数据集合，用于支持经营管理中的决策指定过程

数据仓库: 明确为决策支持服务的
数据库: 为事务处理服务
</code></pre>
<p>2 从数据库到数据仓库</p>
<pre><code>1 如何将大量的数据库中的数据转化为辅助决策信息成为研究热点
2 异构环境数据的转换和共享
	数据库产品的增加，导致异构环境的数据的增加，如何实现这些异构环境数据的转换和共享成为研究热点
3 利用数据进行事务处理转变为利用数据支持决策
	数据库用于事务处理，若要达到辅助决策，需要更多的数据。例如，如何利用历史数据的分析进行预测。对大量数据的综合得到宏观信息等都需要大量的数据
</code></pre>
<p>3 DB数据和DW数据</p>
<pre><code>传统数据库用于事务处理，也叫操作处理，是指对数据库联机进行日常操作，即对一个或一组记录的查询和修改，主要是为企业特定的应用服务的。用户关心的是响应时间，数据的安全性和完整性。数据仓库用于决策分析，是建立决策支持系统(DSS)的基础
</code></pre>
<p>4 DB数据和DW数据的对比表</p>
<pre><code>DB数据			DW数据
细节的			综合的或提炼的
在存取时准去的	代表过去的数据
可更新的			不更新
操作需求事先可知道		操作需求事先不知道
事务驱动			分析驱动
面向应用			面向分析
一次操作数据量小	一次操作数据量大
支持日常操作		支持决策需求
</code></pre>
<h2>数据仓库的特点</h2>
<p>1 数据仓库是面向主题的</p>
<pre><code>主题是数据归类的标准，每一个主题基本对应一个宏观的分析领域
例如，保险公司数据仓库的主题为: 客户、政策、保险金、索赔等

基于应用的数据库组织则完全不同，他的数据只是为处理具体应用而组织在一起的。保险公司按应用组织的数据库有: 汽车保险、生命保险、健康保险和伤亡保险
</code></pre>
<p>2 数据仓库是集成的</p>
<pre><code>数据进入数据仓库之前，必须经过加工与集成。对不同来源的数据进行
数据结构统一和编码。统一原始数据中的所有矛盾过之处，如字段的同
名异义，异名同义，单位不统一，字长不统一。总之，将原始数据结构
做一个从面向应用到面向主题的大转变
</code></pre>
<p>3 数据仓库是稳定的</p>
<pre><code>数据仓库中包括了大量的历史数据。数据经继承进入数据仓库后是极少或者根本不更新的
</code></pre>
<p>4 数据仓库是随时间增长的</p>
<pre><code>数据仓库是数据时限是5~10年，故数据的编码包含时间项，需标明数据的历史使其，有助于 DSS(决策支持系统) 进行时间趋势分析

数据库只包含当前数据，即存储当前时间的正确的有效数据。
</code></pre>
<p>5 数据仓库中的数据量很大</p>
<pre><code>通常的数据仓库数据量为10GB，相当于一般数据库100M的100倍。
数据仓库中 数据的比重为索引和综合数据占2/3,原始数据占1/3
</code></pre>
<p>6 数据仓库软硬件要求较高</p>
<pre><code>需要一个巨大的硬件平台
需要一个并行的数据库系统
</code></pre>
<h2>知识发现和数据挖掘概念</h2>
<p>KDD(从数据库中发现知识)研究的问题: 定性知识和定量知识的发现，(2)知识发现方法， (3) 知识发现的应用等</p>
<h3>知识发现和数据挖掘的定义</h3>
<p>KDD被认为是从数据库中发现有用知识的整个过程。数据挖掘被认为是KDD过程中的一个特定步骤，用专门算法从数据中抽取模式(Pattern)</p>
<pre><code>KDD是从数据集中识别出有效的、新颖的、潜在有用的，以及最终可理解的模式的高级处理过程
</code></pre>
<h3>KDD过程定义</h3>
<p>KDD是从数据集中识别出有效的、新颖的、潜在有用的，以及最终可理解的高级处理过程。</p>
<p>数据集:数据库记录的集合F; 模式: 用语言L表示的F中部分记录的表达式E，它所描述的数据集是集合F的一个子集FE,我们表达式E为模式； 有效、新颖、潜在有用、可理解：表示发现的模式应该是新的，将来有实用价值，能被用户所理解。</p>
<p>KDD过程图如图1.1 所示</p>
<p><img src="/img/kdd1.png" alt=""></p>
<p>KDD过程可以概括为三部分: 数据准备,数据挖掘,结果的解释和评估。</p>
<p>1 数据准备</p>
<pre><code>数据选取，数据预处理，数据变换等三个子步骤
数据选取：确定发现任务的操作对象，即目标数据(Target Data),是根据用户的需要从原始数据库中抽取的一组数据。
数据预处理:一般包括消除噪声、推导计算缺值数据、消除重复记录、完成数据类型转换(如把连续值型数据转换为离散型数据，以便用于符号归纳；或是把离散型数据转换为连续型数据，以便用于神经网络计算)等。
数据变换是削减数据维数或者降维，即从初始特征中找出真正有用的特征以减少数据挖掘时需要考虑的特征或变量个数。
</code></pre>
<p>2 数据挖掘</p>
<pre><code>数据挖掘阶段首先要确定挖掘的任务或目的，如数据分类、聚类、关联规则发现或序列模式发现等。确定了挖掘任务后，就要决定使用什么样的挖掘算法。 
两个因素:
	一是不同的数据有不同的特定，因此需要用与之相关的算法来挖掘；
	二是用户或实际运行系统的要求，有的用户可能希望获取描述型的、容易理解的知识(采用规则表示的挖掘方法显然要好于神经网络之类的方法)，而有的用户只是希望获取预测准确度尽可能高的预测型知识，选择了挖掘算法后，就可以实施数据挖掘操作，换取有用的模式。
</code></pre>
<p>3 结果的解释和评估</p>
<pre><code>数据挖掘阶段发现出来的模式，经过评估，可能存在冗余或者无关的模式，这时需要将其剔除；也有可能模式不满足用户要求，这是需要退回到发现过程前面的阶段，如重新选择数据、采用新的数据变换方法、设定新的参数值，甚至换一种挖掘算法得到。
</code></pre>
<p>数据挖掘仅仅是整个过程中的一个步骤。数据挖掘质量的好坏有两个要素: 一是所采用的数据挖掘技术的有效性，二是用于挖掘的数据的质量和数量(数据量的大小)。 如果选择了错误的数据或不适当的属性，或对数据进行了不适当的转换，则挖掘的结果不会成功。</p>
<p>整个挖掘过程是一个不断反馈的过程。 比如，用户在挖掘图中发现选择的数据不太满意，或使用的数据挖掘技术产生不了期望的结果。 这时，用户需要重复先前的过程，甚至从头重新开始。</p>
<h3>数据挖掘任务</h3>
<p>数据挖掘任务有六项:关联分析、时序模式、聚类、分类、偏差检测以及预测</p>
<p>1 关联分析</p>
<pre><code>关联规则 Apriori
一般用支持度和可信度两个阈值来淘汰哪些无用的关联规则。

支持度表示该规则所代表的事例栈全部事例的百分比。
可行度表示该规则所代表事例满足前提条件事件的百分比，如买面包又买牛奶的顾客占买面包顾客中的90%,可信度为90%。
</code></pre>
<p>2 时序模式</p>
<pre><code>通过时间序列搜索出重复发生概率较高的模式。这里强调时间序列的影响。
在时序模式中，需要找出在某个最小时间内出现比率一直高于某一最小百分比(阈值)的规则。这些规则会随着形式的变化做适当的调整。

时序模式中，一个有重要影响的方法是&quot;相似时序&quot;。 用&quot;相似时序&quot;的方法，要按时间顺序查看时间事件数据库，从中找出另一个或多个相似的时序事件。
例如在零售市场上，找到另一个有相似销售的部门，在股票中找到有相似波动的股票
</code></pre>
<p>3 聚类</p>
<pre><code>在同一个类别中，个体之间的距离较小，不同类别上的个体之间的距离偏大。 聚类增强了人们对客观现实的认识，通过聚类简历宏观概念。

聚类方法包括统计分析方法、机器学习方法和神经网络方法等

在统计分析方法中，聚类分析是基于距离的距离，如欧式距离，海明距离等。这种聚类分析方法是一种基于全局比较的聚类，需要考察所有的个体才能决定类的划分。

在机器学习方法中，聚类是无监督学习，在这里距离是根据概念的描述确定的，顾聚类也称为概念聚类，当聚类对象动态增加时，概念聚类则称为概念形成。

在升级网络中，自组织神经网络方法用于聚类，这是一种无监督学习方法。当给定距离阈值后，各样本按阈值进行聚类。
</code></pre>
<p>4 分类</p>
<pre><code>分类是找出一个类别的概念描述，代表了这类数据的整体信息，即该类的内部描述，一般用规则或决策树模式表示。该模式能把数据库中的元组影射到给定类别中的一个。

一个类可以用特征描述和类别描述。 
分类是利用训练样本集通过有关算法求得
建立分类决策树的方法，典型的有ID3,C4.5等算法

目前，分类方法的研究成功较多，判别方法的好坏，可以从下述3个方面进行: 
(1) 预测准确度(对非样本数据的判别准确度); 
(2) 计算复杂度(方法实现时对时间和空间的复杂度)
(3) 模式的简洁度(在同样效果的情况下，希望决策树小或规则少)
</code></pre>
<p>5 偏差检测</p>
<pre><code>从数据分析中发现异常情况
(1) 分类中的反常实例
(2) 模式的例外
(3) 观察结果对模型预测的偏差
(4) 量值随时间的变化

偏差检测的基本方法是寻找观察结果与参照之间的差别。观察结果常常是某一个域的值或多个域值的汇总。参照是给定模型的预测、外部的标准答案
</code></pre>
<p>6 预测</p>
<pre><code>预测是利用历史数据找出变化规律，建立模型，并用此模型来预测未来数据的种类，特征等

典型的方法是回归分析，即利用大量的历史数据，以时间为变量建立线性或非线性回归方程等。
</code></pre>
<h3>数据挖掘分类</h3>
<p>1 按数据库类型分类</p>
<pre><code>在关系数据库中挖掘知识。关系数据挖掘、模糊数据挖掘、历史数据挖掘和空间数据挖掘等
</code></pre>
<p>2 按数据挖掘对象分类</p>
<pre><code>文本数据挖掘、多媒体数据挖掘和Web网数据挖掘。 
</code></pre>
<p>3 数据挖掘任务分类</p>
<p>4 数据挖掘方法和技术分类</p>
<pre><code>归纳学习类
仿生物技术类
公式发现类
统计分析类
模糊数学类
可视化技术类
</code></pre>
<h3>1.2.4 数据挖掘对象</h3>
<p>1 关系数据库</p>
<p>2 文本</p>
<pre><code>(1) 关键词和特征提取
关键词的提取对于掌握该文本的内容至关重要
(2) 相似检索
(3) 文本聚类
	关键词的相似匹配是对文本聚类的一种方法
(4) 文本分类
	分类器算法
</code></pre>
<p>3 图像与视频数据</p>
<pre><code>(1) 图像与视频特征提取
(2) 基于内容的相似检索
(3) 视频镜头的编辑与组织
</code></pre>
<p>4 Web数据</p>
<h3>1.2.5 数据挖掘的知识表示</h3>
<p>数据挖掘各种方法获得的知识的表示形式主要有6种: 规则，决策树，知识基(浓缩数据)，网络权值，公式和案例</p>
<p>1 规则</p>
<pre><code>规则知识由前提条件和结论两部分组成，前提条件由字段项(属性)取值的合取(交)和析取(并)组合而成，结论为决策字段项(属性)的取值或类别组成
</code></pre>
<p>2 决策树</p>
<pre><code>数据挖掘的信息论方法所获得的知识一般表示为决策树
ID3方法的决策树是由信息量最大的字段(属性)作为根节点，它的各个取值为分支，对各个分枝所划分的数据元组子集，重复建树过程，扩展决策树，最后得到相同类别的子集，以该类别作为叶节点。
</code></pre>
<p>3 知识基(浓缩数据)</p>
<pre><code>数据挖掘方法能计算出数据库中字段项(属性)的重要程度，对于不重要的字段可以删除，对数据库中的元组(记录)能按一定的原则合并，这样，通过数据挖掘的方法能大大压缩数据库的元组和字段项，最后得到浓缩数据，称为知识基，它是原数据库的精华，很容易转换成规则知识。
</code></pre>
<p>4 网络权值</p>
<p>5 公式</p>
<p>6 案例</p>
<pre><code>案例是指人们经历过的一次完整的事件。当人们要解决一个新问题时，总是先回顾自己以前处理过的类似事件(案例)，利用以前案例中解决问题的方法或者处理的结果，作为参考并进行适当的修改，以解决当前新问题。

利用这种思想建立起基于案例推理(Case Based Reasoning,CBR)。CBR的基础是案例库，在案例库中存放这大量成功或失败的案例。CBR利用相似检索技术，对新问题到案例库中搜索相似案例，再经过对旧案例的修改来解决新问题。

问题描述: 对求解的问题及周围世界或环境的所有特征的描述
解描述: 对问题求解方案的描述
效果描述: 描述解决方案后的结果情况，是失败还是成功。
</code></pre>
<h2>数据挖掘方法和技术</h2>
<p>归纳学习方法，仿生物技术，公式发现，统计分析方法，模糊数学方法和可视化技术</p>
<p>###1.3.1 归纳学习方法
归纳学习方法是目前重点研究的方向，研究成果较多，从采用的技术上看，分为信息论方法(决策树方法)和集合论方法两大类。</p>
<ol>
<li>
<p>信息论方法</p>
<p>利用信息论的原理建立决策树
ID3: 信息增益</p>
</li>
<li>
<p>集合论方法</p>
<p>关联规则挖掘</p>
</li>
</ol>
<h3>1.3.2 仿生物技术</h3>
<p>1 神经网络算法</p>
<pre><code>神经网络方法
1 前馈式网络
2 反馈式网络
3 自组织网络
</code></pre>
<p>2 遗传算法</p>
<pre><code>繁殖: 旧种群选择出生命力强的个体产生新种群的后代
交叉: 交叉是指选择两个不同个体的部分，形成新个体
变异: 变异是指对某些个体的某些基因进行变异
</code></pre>
<h3>1.3.3 公式发现</h3>
<h3>1.3.4 统计分析方法</h3>
<pre><code>1 常用统计 最大值，最小值，总和和平均值
2 相关分析
	相关分析是指通过求变量间的相关系数来确定变量间的相关程度
3 回归分析
	回归分析是指通过建立回归方程(线性或非线性)以满足变量间的数量关系，再利用回归方程进行预测。

4 假设检验
	假设检验是指在总体存在某些不确定情况时，为了推断总体的某些性质，剔除关于总体的某些假设，对此假设利用置信区间来检验，即任何落在置信区间之外的假设判断为拒绝，任何落在置信区间之内的假设判断为接受
5 聚类分析

6 判别分析
</code></pre>
<h3>1.3.5 模糊数学方法</h3>
<h3>1.3.6 可视化技术</h3>
<p>DSS 决策支持系统</p>
<p>习题:</p>
<pre><code>1 数据仓库的定义是什么
2 数据仓库兴起的原因是什么
3 数据库数据和数据仓库有什么不同
4 数据仓库的特点是什么
5 画出数据仓库结构图，说明各层数据的内容
6 数据集市的含义是什么，有什么特点
7 知识发现过程由哪三部分组成，每部分的工作是什么
8 数据挖掘的任务有哪些，每项任务的含义是什么
9 聚类与分类有什么不同
10 数据挖掘的对象有哪些，各自的特点是什么
11 数据挖掘的知识表示有哪些
12 规则知识与决策树知识和知识基是等价的吗
13 人类社会的知识表示什么，与计算机中的知识表示有什么不同
14 为什么要研究计算机中的知识表示
15 数据挖掘的归纳学习方法有哪几种，各方法的含义是什么
16 数据挖掘的仿生物技术有哪几种？ 各方法的含义是什么
17 公式发现与曲线拟合有什么不同，公式发现所得的公式与曲线拟合得到的公式有什么不同
18 公式发现中的BACON方法与FDD方法的基本思想是什么
19 统计分析方法所处理的数据主要属于哪种类型
20 人工智能的机器学习与数据挖掘有什么关系
21 数据库中的数据挖掘与数据仓库中的数据挖掘有什么不同
22 新决策支持系统的组成有哪些，与传统的决策支持系统有什么不同
23 综合决策支持系统的组成有哪些，为什么要研究综合决策支持系统
24 什么是商业智能
25 如何理解商业智能与新决策支持系统的相同和不同之处
26 什么是知识管理，知识管理的基础是什么
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/22/frature-importance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/frature-importance/" itemprop="url">frature_importance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T17:06:41+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>GBDT:feature_importance及Spark:feature_importance计算</h2>
<p>参考文档： <a href="http://www.cnblogs.com/yxzfscg/p/5142620.html" target="_blank" rel="noopener">http://www.cnblogs.com/yxzfscg/p/5142620.html</a>,<a href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/tree/_tree.pyx" target="_blank" rel="noopener">https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/tree/_tree.pyx</a></p>
<p>GBDT其底层实现就是决策树，因此，feature_importance其实现即为GBDT实现。</p>
<p>主要代码</p>
<pre><code>importance_data[node.feature] += (
                    node.weighted_n_node_samples * node.impurity -
                    left.weighted_n_node_samples * left.impurity -
right.weighted_n_node_samples * right.impurity)
</code></pre>
<p>采用iris数据源进行验证说明</p>
<pre><code>from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
iris = load_iris()
X = iris.data
y = iris.target
print(X[0])
dt = DecisionTreeClassifier(criterion='gini')
dt.fit(X, y)
print(dt.feature_importances_)

from sklearn.tree import export_graphviz
with open('feature_tree.dot','w')as f:
	f=export_graphviz(dt)
</code></pre>
<p>生成决策树模型：</p>
<pre><code>采用该命令： dot -Tpdf  tree.dot -o tree.pdf
</code></pre>
<p><img src="/img/fea_01.png" alt=""></p>
<pre><code>输出feature_importance: [ 0.02666667  0.          0.05072262  0.92261071]
</code></pre>
<p>验证过程：
从树顶部开始：</p>
<p><img src="/img/fea_02.png" alt=""></p>
<p>上面三者之和近似100(100.005),则特征重要性可以得出。</p>
<p>上面的过程不涉及树的权重，因为只有一颗树，如果类似GBDT这样的多棵树就要加上每棵树的权重。真正的代码实现如下：</p>
<pre><code>total_sum = np.zeros((self.n_features, ), dtype=np.float64)
    for stage in self.estimators_:
        stage_sum = sum(tree.feature_importances_
                        for tree in stage) / len(stage)
        total_sum += stage_sum

    importances = total_sum / len(self.estimators_)
    return importances
</code></pre>
<p>在一些地方加上打印过程，具体如下：</p>
<pre><code>	[ 0.08026236  0.          0.32461037  0.          0.          0.55035696
	0.04477031  0.        ]
	stage_sum 0.0802623563677
	total_sum 0.0802623563677
	[ 0.          0.          0.25505309  0.1419576   0.          0.40878994
	0.19419937  0.        ]
	stage_sum 0.0
	total_sum 0.0802623563677
	[ 0.07849338  0.          0.35527078  0.          0.          0.56623584
	0.          0.        ]
	stage_sum 0.0784933756874
	total_sum 0.158755732055
	[ 0.          0.          0.26975468  0.08468996  0.          0.41409671  0.23145865  0.        ]
	stage_sum 0.0
	total_sum 0.158755732055
	[ 0.08331287  0.          0.25748023  0.07290349  0.          0.37375141 0.212552    0.        ]
	stage_sum 0.0833128747713
	total_sum 0.242068606826
	total_sum / len(self.estimators_) [ 0.04841372  0.          0.29243383  0.05991021  0.          0.46264617
	0.13659606  0.        ]
	feature_importance_ [ 0.04841372  0.          0.29243383  0.05991021  0.          0.46264617
	0.13659606  0.        ]
</code></pre>
<p>简单来说，就是叠加每一棵树的对应特征的feature_importance_,然后除以总的树棵树，就是所得的feature_importance,并没有添加对应的weight。</p>
<p>这应该就是python和spark的不同之处，python注重每棵树的特性，而spark注重整棵树的特性，整棵树的weight是能够得到的，但是无法计算出特征重要性。</p>
<p>因此，计算spark 的feature_importance 可以用spark生成的树来计算每个节点的gini系数，然后按照上述计算过程计算importance。采用倒推的方式进行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning-02/" itemprop="url">Ensemble Learning 02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T19:13:09+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Boosting</h2>
<h2>2.2 Boostrapping and Bagging</h2>
<p>有放回的抽样，每一个数据不被选中的概率是 0.368
<img src="/img/ens2_1.png" alt=""></p>
<p>boostrapping</p>
<p><img src="/img/ens2_2.png" alt="">
	样本集是N个样本，随机选择N个，选择B次，得出B个学习器
	计算boostrap estimate 和accuracy</p>
<p>Bagging(bootstrap aggregation自举汇聚法)</p>
<p><img src="/img/ens2_3.png" alt=""></p>
<pre><code>bagging
* increases classifier stability and accuracy
* reduce classifier variance,in terms of the bias-variance decomposition
</code></pre>
<p><img src="/img/ens2_4.png" alt=""></p>
<p>BaggingClassifier分析</p>
<pre><code>class sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=1, random_state=None, verbose=0)

base_estimator: 弱分类器
n_estimators: 弱分类器个数
max_sample: 弱分类器训练样本数，
max_features: 弱分类器训练样本特征数目
bootstrap: 是否是有放回抽样  True
bootstrap_features: 特征是否是有放回 False
oob_score:是否使用袋外数据去估计错误率
warm_start: 
n_jobs: 并行计算
random_state: 
verbose: 冗长

base_estimator_ : estimator
estimators_ : list of estimators
estimators_samples_ : list of arrays
estimators_features_ : list of arrays
classes_ : array of shape = [n_classes]
n_classes_ : int or list
oob_score_ : float
oob_decision_function_
</code></pre>
<h2>Boosting Algorithms</h2>
<p>无放回采样</p>
<p><img src="/img/ens2_5.png" alt=""></p>
<p><img src="/img/ens2_6.png" alt=""></p>
<h2>AdaBoost Algorithm</h2>
<p>ada训练注重的是每个样本的样本权重，
<img src="/img/ens2_7.png" alt=""></p>
<p><img src="/img/ens2_8.png" alt=""></p>
<p>第四行的h是一个阶跃函数，x&gt;0,y=1,x&lt;0,y=0;</p>
<p>这里的一个点就是弱分类器h的确定。</p>
<p>errm 就是 第m个分类器的加权错误率</p>
<p>algorithm：这个参数只有AdaBoostClassifier有。主要原因是scikit-learn实现了两种Adaboost分类算法，SAMME和SAMME.R。两者的主要区别是弱学习器权重的度量，SAMME使用了和我们的原理篇里二元分类Adaboost算法的扩展，即用对样本集分类效果作为弱学习器权重，而SAMME.R使用了对样本集分类的预测概率大小来作为弱学习器权重。由于SAMME.R使用了概率度量的连续值，迭代一般比SAMME快，因此AdaBoostClassifier的默认算法algorithm的值也是SAMME.R。我们一般使用默认的SAMME.R就够了，但是要注意的是使用了SAMME.R， 则弱分类学习器参数base_estimator必须限制使用支持概率预测的分类器。SAMME算法则没有这个限制。</p>
<p>下面进行一个尝试:基于单层决策树构建弱分类器</p>
<pre><code>单层决策树(决策树桩)是一种简单的决策树: 仅仅基于单个特征来做决策。由于这棵树只有一次分裂过程，实际上就是一个树桩。
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning-01/" itemprop="url">Ensemble Learning 01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T17:13:37+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Ensemble Learning</h2>
<h3>介绍</h3>
<p>集成学习： reduce variabce -- impoove accuracy</p>
<h2>1.1.1</h2>
<p>所有的分类器错误都可以被归结为两类:</p>
<pre><code>bias: 分类器的准确性
variance: 在不同训练集上训练时 分类器的精度
趋势关系: 分类器有低bias 那么则倾向于高的variance
vice versa: 反之亦然。
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning/" itemprop="url">Ensemble Learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T13:07:05+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>集成学习</h2>
<p>继承学习中的误差(方差与偏差)</p>
<p>任何模型中出现的误差都可以被拆解为三个要素</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/Wb6I0AHP.png" alt=""></p>
<p>偏差Bias Error: 量化预测值与实际值差异的均值(期望)。高偏差的出现表示模型遗漏了重要的变化趋势，就是说这个模型表现并不乐观</p>
<p>方差Variance: 个体预测结果离散程度的量化，一个拥有过大方差的模型将会对训练总体过度的拟合，从而无法保证对训练集外的个体进行准确的预测。</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/6UBxj3Rg.png" alt=""></p>
<p>需要注意的点: 通常情况下，你会发现偏差的降低会导致模型总误差的减小，但当过了某个特定的点之后，再增加模型的复杂度则会适得其反。最终，你的模型将面临过度拟合的问题，并且具有了较高的方差</p>
<p>理论上，最优的模型应该做到尽量保持偏差和方差的的均衡。</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/Ugj1NJBn.png" alt=""></p>
<p>Bagging</p>
<p>bagging 在小数据集上实现相似的学习器然后取所有预测的均值。一般的bagging中，可以使用不同的学习器在不同的样本中。</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2015/07/bagging.png" alt=""></p>
<p>Boosting</p>
<p>Boosting是一种迭代算法，能根据最后一个分类的预测情况来调整观测值的权重。如果一个观测值的分类被预测错误，那么该算法将增加这个观测值的权重，否则反之。通常情况下，Boosting能有效减少偏差并构建出有效的模型，同时也面临着拟合的风险。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Solidity-Localtion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Solidity-Localtion/" itemprop="url">Solidity Localtion </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T11:18:46+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Location</h2>
<pre><code>pragma solidity ^0.4.9;

contract Loc1{
struct S{string a;uint b;}

//parameter is memory
function assign(S s) internal{
    // local variable is storage
    S memory tmp =s;
}
}
</code></pre>
<p>// convert storage to storage</p>
<pre><code>contract Loc2{
struct S{string a;uint b;}

S s;

function convertToStorage(S storage  s) internal{
    S tmp =s;
    tmp.a = &quot;Test&quot;;
}
function call()  constant returns  (string str)
{
    convertToStorage(s);
    return s.a; //Test
}
}
</code></pre>
<p>// memory to state variable</p>
<pre><code>contract Loc3{
struct S{string a;uint b;}

S s;

function memoryToState(S memory tmp) internal{
    s = tmp;
    tmp.a =&quot;Test&quot;;
}
function call() constant returns (string)
{
    S memory tmp = S(&quot;memory&quot;,0);
    memoryToState(tmp);
    return s.a;
}
}
</code></pre>
<p>// memory to Local variable</p>
<pre><code>contract Loc4 {
struct S{string a;uint b;}
function memoryToLocal(S s) internal{
    // Error
    // S tmp =s;
    S memory tmp =s;
}
}
</code></pre>
<p>// storage to memory</p>
<pre><code>contract Loc5{
struct S{string a;uint b;}

// storage variable
S s= S(&quot;storage&quot;,1);

function storageToMemory(S storage x) internal{
    // storage to memory
    S memory tmp= x;
    tmp.a = &quot;Text&quot;;
}
function call() constant returns (string){
    storageToMemory(s);
    return s.a;
}
}


contract Loc6{
struct S{string a;uint b;}

function memoryToMemory(S s ) internal{
    S memory tmp =s;
    tmp.a = &quot;other memory&quot;;
}
function call() constant returns (string)
{
    S memory mem = S(&quot;memory&quot;,1);
    memoryToMemory(mem);
    return mem.a;
}
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Spark/" itemprop="url">Spark</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T10:40:23+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/15/solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/solidity/" itemprop="url">solidity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-15T13:44:07+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Tutorials</h2>
<pre><code>pragma solidity ^0.4.9;

contract SimpleStorage {
uint data;

function setData(uint x) public{
    
    data = x;
}

function getData() public constant returns (uint)  {
    
    return data;
}
}
</code></pre>
<h2>使用Truffle 部署测试协议</h2>
<pre><code>mkdir hello-world
cd hello-world
truffle init

truffle test

...
</code></pre>
<p>建立协议</p>
<pre><code>truffle create contract HelloWorld
contracts/HelloWorld.sol

pragma solidity ^0.4.9;

contract HelloWorld {
address private creator;
address private lastCaller;
string private message;
uint private totalGas;



function HelloWorld(){
     /*
  We can use the special variable `tx` which gives us information
  about the current transaction.

  `tx.origin` returns the sender of the transaction.
  `tx.gasprice` returns how much we pay for the transaction
	*/
    creator = tx.origin;
    totalGas = tx.gasprice;
    message = &quot;Hello World&quot;;
}

function getMesage() constant returns (string) {
    return message;
}

function getLastCaller() constant returns(address){
    return lastCaller;
}
function getCreator() constant returns (address){
    return creator;
}
function getTotalGas() constant returns(uint) {
return totalGas;
}
//End: getters

//Being: setters
function setMessage(string newMessage) {
message = newMessage;
lastCaller = tx.origin;
totalGas += tx.gasprice;
}
}
</code></pre>
<p>Migration:我们完成了一个协议，需要用一种方式将这个协议部署到区块链中。truffle使用migration方式，压缩和部署contracts</p>
<pre><code>truffle create migration 
生成一个文件: 1521178244_deploy_hello_world.js

在js文件中部署协议

const HelloWorld = artifacts.require('HelloWorld')
	module.exports = function(deployer) {
deployer.deploy(HelloWorld)
};
</code></pre>
<p>需要将协议部署到测试区块链中  truffle migrate --reset</p>
<p>Testing</p>
<pre><code>truffle create test HelloWorld
test/hello_world.js

const HelloWorld = artifacts.require('HelloWorld')

contract('HelloWorld', function(accounts) {
it('sets the first account as the contract creator', async function() {
		const contract = await HelloWorld.deployed()
		const creator = await contract.getCreator()
		
		assert.equal(creator, accounts[0],'main account is the creator')
})
it('has hello world as initial message' ,async function(){
				const contract = await HelloWorld.deployed()
				
				const message = await contract.getMesage()
				assert.equal(message, 'Hello World', 'message is hola mundo')
		})
it('changes the message via setMessage', async function() {
const contract = await HelloWorld.deployed()

// Execute a transaction and change the state of the contract.
await contract.setMessage('hola mundo')

// Get the new state.
const message = await contract.getMesage()

assert.equal(message, 'hola mundo', 'message is hola mundo')
})
});
</code></pre>
<p>使用测试命令</p>
<pre><code>truffle test
测试输出

Contract: HelloWorld
√ sets the first account as the contract creator
√ has hello world as initial message
√ changes the message via setMessage (91ms)
</code></pre>
<p>解析这个过程 <a href="https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/" target="_blank" rel="noopener">https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/</a></p>
<p>1 协议文件</p>
<pre><code>构造函数中一个变量tx

首先看下面的全局变量

block.coinbase(address): 当前块的矿场的地址
block.difficulty(uint) : 当前块的难度
block.gaslimit(uint)   : 当前块的gaslimit
block.number(uint)     : 当前块的数量
block.blockhash(function(uint) returns(bytes32)): 给定的块的hash值，只有最近工作的256块的hash值
block.timestamp(uint)  ： 当前块的时间戳
msg.data(bytes)			: 完整的calldata
msg.gas(uint)			: 剩余gas
msg.sender(address)		: 消息的发送者
msg.value(uint)			: 和消息一起发送的wei的数量
now(uint):				当前块的时间戳(block.timestamp的别名)
tx.gasprice(uint):		交易的gas价格
tx.origin(address):		交易的发送者(全调用链)
sha3(...) retuens (bytes32): 计算(紧凑排列的) 参数的 Etherum-SHA3 hash值
sha256(...) returns (bytes32): 计算(紧凑排列的)参数的SHA256 hash值
ripemd160(...) returns (bytes20): 计算256个参数的RIPEMD
ecrecover(bytes32, uint8, bytes32, bytes32) returns (address):椭圆曲线签名公钥恢复
addmod(uint x, uint y, uint k) returns (uint):计算（x + y）K，加法为任意精度，不以2 ** 256取余
mulmod(uint x, uint y, uint k) returns (uint):计算（XY）K，乘法为任意精度，不以2 * 256取余
this (current contract’s type): 当前合约，在地址上显式转换
super:在层次关系上一层的合约
selfdestruct(address):销毁当前的合同，将其资金发送到指定address地址
.balance:address地址中的账户余额（以wei为单位）
.send(uint256) returns (bool):将一定量wei发送给address地址，若失败返回false。
</code></pre>
<p>contract中的分析</p>
<pre><code>creator = tx.origin;  //交易的发送者，协议的关联者，
这里和第一个account账户关联
totalGas = tx.gasprice;
message = &quot;Hello World&quot;;

const contract = await HelloWorld.deployed()
const creator = await contract.getCreator()
console.log(creator)
console.log(accounts[0])

0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278

tx.gasprice: BigNumber { s: 1, e: 11, c: [ 100000000000 ] }

也就是在部署这个协议的时候，默认将accounts作为tx.origin，那么协议的发送者是谁?
并且会调用构造函数

tx.origin: 0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
</code></pre>
<p>下面修改协议，对上面的数据进行一次重新测试</p>
<pre><code>    coinbase = block.coinbase();
    difficulty = block.difficulty();
    gaslimit = block.gaslimit();
    number = block.number();
    nottime = block.timestamp();
    calldata = msg.data();
    gas = msg.gas();
    sender = msg.sender();
    weivalue = msg.value();
</code></pre>
<p><img src="/img/solidity01.png" alt=""></p>
<h2>Solidity by Example</h2>
<p><strong>Voting</strong></p>
<p>how to assign voting rights to the correct persons and how to prevent manipulation.</p>
<pre><code>pragma solidity ^0.4.9;


contract Ballot {
// struct type
struct Voter{
    uint weight;
    bool voted;
    address delegate;
    uint vote;
}

struct Proposal{
    bytes32 name;
    uint voteCount;
}

address public chairperson;
mapping(address =&gt; Voter) public voters;
Proposal[] public proposals;


function Ballot(bytes32[] proposalNames) public {
    chairperson = msg.sender;
    voters[chairperson].weight =1;

    for(uint i=0;i&lt;proposalNames.length;i++)
    {
        proposals.push(Proposal({
            name: proposalNames[i],
            voteCount:0
    }));
    }
}
// Give `voter` the right to vote on this ballot.
// May only be called by `chairperson`.
function giveRightToVote(address voter) public {
    //If the arguments of 'require' evaluate to 'false'
    // it terminates and reverts all changes to
    // the state and to Ether balances. It is often
    // a good idea to use this functions are called incorrectly.proposals//
    // but watch out,this will currently also consume all provided gas
    //(this is planned to change in the future)
    require(
        (msg.sender == chairperson) &amp;&amp;
         !voters[voter].voted &amp;&amp; (voters[voter].weight ==0)
        );
    voters[voter].weight =1;
}

function delegate(address to) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);

    require(to != msg.sender);

    while( voters[to].delegate != address(0))
    {
        to = voters[to].delegate;
        require(to != msg.sender);
    }
    sender.voted = true;
    sender.delegate = to;
    Voter storage delegate_ = voters[to];
    if(delegate_.voted){
        proposals[delegate_.vote].voteCount += sender.weight;
    }else{
        delegate_.weight += sender.weight;
    }

}

function vote(uint proposal) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);
    sender.voted = true;
    sender.vote = proposal;

    proposals[proposal].voteCount += sender.weight;
}

function winningProposal() public view returns (uint winningProposal_)
{
    uint winningVoteCount =0;
    for(uint p=0; p&lt;proposals.length; p++)
    {
        if (proposals[p].voteCount &gt;winningVoteCount){
            winningVoteCount = proposals[p].voteCount;
            winningProposal_ =p;
        }
    }
}

function winnerName() public view returns (bytes32 winnerName_)
{
    winnerName_ = proposals[winningProposal()].name;
}
}

构造函数:
合约的构造者拥有 weight =1
候选人数组: name, 票数 0

giveRightToVote(address voter)
	赋予投票人的投票权利，首先保证合约的拥有者 是主席
	投票者 没有投过票， 权力是0，才能赋予投票权

delegate: 将自己的投票权限给代理人，让代理人帮助投票
	

协议稍微有点复杂，但还是看完了，里面有个问题
一: 测试的时候  [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]作为议案，供用户投票
二: giveRightToVote: 可以输入 1，2，3等值，作为voter账户，
初始化的时候会将bool初始化为false，uint为0，address 为0
三： delegate代理，这个代理的入参是address to，但是这个动作
的发起者是msg.sender,在测试的时候是和create的账户保持一致
的，作为A，然后to作为B，把A的投票权限让B去代理，那么最终的实
际操作在B中，但是也就意味着这样无法完成下面的vote操作，因为
vote操作需要的是msg.sender的投票权限，怎么才能切换用户或者
address，或者msg.sender从而实现不同用户的切换
</code></pre>
<h2>Blind Auction(暗箱拍卖)</h2>
<p>这是一个非公开的拍卖系统，在透明的平台运行非公开拍卖看起来是矛盾的，但是密码学可以做到这一点。</p>
<p>在拍卖期间，参与者把自己的出价加密发送给拍卖系统，除了自己，任何人不知道出价是多少。当拍卖结束，参与者把出价明文发给拍卖系统，系统用明文加密运算，跟之前发送的密文比对，一致的话说明出价跟之前一样，出价有效。</p>
<p>在传统领域，很多业务很容易产生暗箱操作，智能合约让参与者跟工作人员都无法干预系统，系统也没有人的行为，全部是自动执行的代码，使业务变得透明公平，这对产业的变革是颠覆性的。</p>
<h2>Lauout of a Solidity Source File</h2>
<p>pragma  0.x.0  x.0.0</p>
<pre><code>pragma solidity ^0.4.21
</code></pre>
<p>这样一个源文件将不会被低于0.4.0 的编译器编译，或者高于0.5.0 的编译器编译。^ 代表直到0.5.0 之前的编译器都可以编译</p>
<p>导入其他文件</p>
<pre><code>import &quot;filename&quot;;
import * as symbolName from &quot;filename&quot;;
</code></pre>
<p>Paths</p>
<p>注释</p>
<pre><code>pragma solidity ^0.4.0;

/** @title Shape calculator. */
contract shapeCalculator {
/** @dev Calculates a rectangle's surface and perimeter.
  * @param w Width of the rectangle.
  * @param h Height of the rectangle.
  * @return s The calculated surface.
  * @return p The calculated perimeter.
  */
function rectangle(uint w, uint h) returns (uint s, uint p) {
    s = w * h;
    p = 2 * (w + h);
}
}	
</code></pre>
<h2>Structure of a Contract</h2>
<p>State Variables</p>
<pre><code>uint storedData;  // state variable
</code></pre>
<p>Functions</p>
<pre><code>function bid() public payable // function
</code></pre>
<p>Function Modifiers</p>
<pre><code>函数修饰符可以用声明的方式修改函数的语义。

modifier onlySeller() // Modifier
</code></pre>
<p>Events</p>
<pre><code>event HighestBidIncreased(address bidder,uint amount) // Event
</code></pre>
<p>Struct Types</p>
<pre><code>struct Voter{
		uint weight;
		bool voted;
	}  // Struct
</code></pre>
<p>Enum Types //枚举</p>
<pre><code>enum State { Created,Locked,Inactive } // enum
</code></pre>
<h2>Types</h2>
<pre><code>bool: true/false  !, &amp;&amp;, ||, == ,!=
int/uint: uint--&gt; uint 256, int --&gt;int256
&lt;=, &lt; ==,!=,&gt;=, &gt;
位运算: &amp;，| ^ 
&lt;&lt; 左移，  &gt;&gt; 右移
</code></pre>
<p>address: 20 byte value</p>
<pre><code>Members of Addresses: balance and transfer
balance: 查询地址的余额
transfer: 发送Ether(wei 计数) 

address x = 0x123;
address myAddress = this;
if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 

send：
	使用send的时候有些危险，如果call stack depth是1024，或者接收者运行超出gas，交易失败。因此为了交易的安全，检查使用send的返回值； 使用transfer更安全: 或者使用一个方式 接收者撤回money

call,callcode,delegatecall
</code></pre>
<p>Fixed-size Bytes</p>
<pre><code>bytes1,bytes2,bytes3,....bytes32, byte 是bytes1的别名

it is possible to use n array of bytes as byte[], but
is is wasting a lot of space.,31 bytes every element, 
to be exact, when passing in calls, it is better to use bytes
</code></pre>
<p>Dynamically-sized byte array</p>
<pre><code>bytes: 是一个可变长的数组，不是一个value-type
string: 动态可变长的UTF-8编码的字符串。
</code></pre>
<p>Address Literals (地址常量)</p>
<p>Rational and Integer Literals</p>
<p>String Literals</p>
<p>Hexadecimal Literals</p>
<p>Enums</p>
<pre><code>	enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
	ActionChoices choice;
	ActionChoices constant defaultChoice = ActionChoices.GoStraight;
</code></pre>
<p>Function Types</p>
<pre><code>function (&lt;parameter types&gt;) {internal|external} [pure|constant|view|payable] [returns (&lt;return types&gt;)]

默认情况下，函数是内部的，因此，internal可以忽略

function f() public view returns (bytes4) {
	return this.f.selector;
}


//外部函数不能在内部调用
function Pyramid(uint l) public pure returns (uint){
    return ArrayUtils.range(l).map(square).reduce(sum);
}
function square(uint x) external pure returns (uint)
{
    return x*x;
}
function sum(uint x,uint y) external pure returns (uint)
{
    return x+y;
}
因此上面的句子编译失败
</code></pre>
<p>功能修饰符</p>
<pre><code>修饰符可用于轻松更改功能的行为，例如，可以在执行功能之前自动检查条件。修饰符是合同的可继承属性，可能会被派生合同覆盖。

//此合约仅定义修饰符，但不是用它 - 它将用于派生合约
//函数体插入其中，特殊符号 _; 在修饰符的定义出现。
//这意味着如果所有者调用此函数，则执行该函数，否则抛出异常。
modifier onlyOwner{
	require(msg.sender == owner; )
	-;
}
</code></pre>
<p>Reference Types （引用类型）</p>
<pre><code>因为变量间的复制开销比较大，因此一般可以考虑存储在memoey或者storage中

默认的 对于函数参数(包括返回值)是在memory中，本地变量是在storage中
state variables 强制被存储在storage中

还有第三个数据位置，calldata，是一个不能被修改的，不能被持久化的位置，并且函数参数被存储。函数参数被强制性的存储在calldata中。
</code></pre>
<p>数据位置非常重要，因为它们改变了赋值的行为：存储和内存之间的赋值以及状态变量（甚至来自其他状态变量）总是创建一个独立的副本。对本地存储变量的赋值只分配一个引用，而这个引用总是指向状态变量，即使后者在这期间也被改变了。另一方面，从内存存储引用类型到另一个内存存储引用类型的赋值不会创建副本。</p>
<pre><code>uint[] x; // 本地变量存储在storage中
function f(uint[] memorArray)： 函数参数保存在memory中
x=memoryArray; 复制一份memory中的数据到storage中。

var y=x;// 本地变量的赋值是分配一个指向storage的引用
y.length=2; //通过修改引用的大小类修改实际存储对象
delete x;  修改storage中的数据
y=memoryArray; // 不能给一个指针变量赋值一个memory变量。
</code></pre>
<h2>分析</h2>
<p>局部变量是函数中声明的变量，状态变量是合约内声明的共有变量</p>
<p>1 storage 转换为storage</p>
<pre><code>当把一个storage类型的变量赋值给另一个storage时，只是修改了指针
S s; // storage
funciton convertToStorage(S storage s) internal{
	S tmp =s;  // storage  --&gt; storage
	tmp a =&quot;Test&quot;;
}
function call() returns (string)
{
	convertToStorage(s);
	return s.a;//  Test
}
将传入的storage变量，赋值给另一个storage变量，并修改值，最后发现合约的状态变量s也被改变了， 引用的作用
</code></pre>
<p>memory转换为storage</p>
<pre><code>因为局部变来那个和状态变量的类型都可能是storage，分开来讲
</code></pre>
<p>memory赋值给状态变量(原来memory的值是直接可以拷贝给storage的状态变量的，而不能拷贝给局部变量)</p>
<pre><code>将一个memory类型的变量赋值给一个状态变量时，实际上是将内存变量拷贝到存储中

S s;  // storage
function call() returns(string){
	S memry tmp = S(&quot;memory&quot;,0);
	memoryToState(tmp);
	return s.a;
}
function memoryToState(S memory tmp) internal{
	s= tmp;
	tmp.a =&quot;Test&quot;;
}
memory --&gt; 状态变量，是值拷贝
</code></pre>
<p>memory赋值给局部变量</p>
<pre><code>由于在区块链中，storage必须是静态分配存储空间的。局部变量虽然是一个storage的，但是仅仅是一个storage类型的指针。如果进行这样的赋值，会产生错误。

S tmp=s;  是错误的
</code></pre>
<p>storage到memory， 也是值的拷贝，注意storage到memory只需要强制定义左边的类型， 是可以转换成功的。</p>
<p>memory 到memory: memory 之间是引用传递，不是值传递</p>
<p>Arrays</p>
<pre><code>bytes 和string 是特殊的数组，bytes和byte[] 比较详细，但是是稠密的。
</code></pre>
<p>将数组保存在Memory中</p>
<pre><code>将数组变量保存在内存中可以使用new关键字，和保存在storage中相比，不能通过.length 重新划分memory数组长度
</code></pre>
<p>Array Literals/Inline Arrays</p>
<pre><code>数组常量 作为一个表达式 并且不需要马上赋值
function g(uint[3] _data) public pure{
}
则传入参数的形式是
g([uint(1),2,3]);
数组常量是一个memory数组，长度固定，基本类型是给定数据的普遍类型，[1,2,3]是uint8[3] memory,因为每一个元素的类型是uint8,因此，需要将第一个类型转换为uint。注意，固定长度的memory数组不能被分配给动态长度的memory数组。

也就是说 uint[] x= [uint(1),3,4]是不行的，后面的是固定长度的，前面的是可变长度的。uint[] x 是一个storage变量。

uint[] memory  x=new uint[](3)
 x = [uint(3),3,4]
Type uint256[3] memory is not implicitly convertible to expected type uint256[] memory.
后面的是固定长度的数组，前面的是可变长的数组，不能赋值?
有点奇怪
</code></pre>
<p>Members</p>
<pre><code>length: 动态数组可以在storage(不是在memory)中调整大小通过.length 

那么动态数组应该如何定义呢?
uint[] x = new uint[](4)
TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] storage pointer

push: 动态stoeage 数组和bytes 有一个函数push，可以用来追加一个新的元素在数组的末尾。 函数返回一个新的长度
</code></pre>
<p>Structs</p>
<p>Mappings</p>
<p>delete</p>
<pre><code>delete a 恢复初始值。 数组的话是长度为0
</code></pre>
<p>Conversions between Elementary Types</p>
<p>货币单位(Ether Units)</p>
<p>一个字面量的数字，可以使用后缀wei,finney,szabo或ether来在不同面额中转换。不含任何后缀的默认单位是wei。如2 ether == 2000 finney的结果是true。</p>
<pre><code>（2 ether == 2000 finney）
</code></pre>
<p>时间单位</p>
<pre><code>seconds,minutes,hours,days,weeks,years
1== 1 secondes
1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours 
1 weeks == 7 dyas
1 years == 365 dyas
</code></pre>
<p>Error Handling</p>
<pre><code>assert(bool condition): 如果条件不满足则抛出异常
require(bool condition):
revert(): abort execution and revert state changes
</code></pre>
<p>数学公式</p>
<pre><code>addmod(uint x,uint y,uint k) returns (uint)
	(x+y)%k
keccak256(...) returns (bytes32)
	compute the etherum-ShA03 hash of the arguments
keccak256(12)
	0x4de0e96b0a8886e42a2c35b57df8a9d58a93b5bff655bc37a30e2ab8e29dc066

sha256
sha3 == keccak256
</code></pre>
<p>地址相关</p>
<pre><code>&lt;address&gt;.balance  Wei
&lt;adderss&gt;.transfer()
		 . send
		 .call
		 .callcode
		 .delegatecall
</code></pre>
<p>协议相关的</p>
<pre><code>this(current contract's type)
selddestruct(address recipient)
	销毁当前合约，将他的funds发送给指定地址
suicide(address recipient)
	过时了，是selfdestruct的别称
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/12/区块链01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/区块链01/" itemprop="url">区块链01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T13:06:57+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Windows</h2>
<p><a href="https://github.com/ethereum/go-ethereum/releases/" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/</a></p>
<p>安装后用cmd命令打开命令行，进入到你安装geth的目录下，输入geth –help 命令，如果输出一大堆关于geth的信息如下图则说明安装成功。当前geth命令只能在geth对应的目录下使用，如果想要在任何目录使用geth命令，只要把你安装geth的目录的路径加入到系统环境环境变量path中即可。</p>
<p><a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11</a></p>
<p><a href="https://ethereum.github.io/go-ethereum/downloads/" target="_blank" rel="noopener">https://ethereum.github.io/go-ethereum/downloads/</a>
最全的下载地址</p>
<p>创世文件的定义
<a href="https://my.oschina.net/stevex/blog/746669" target="_blank" rel="noopener">https://my.oschina.net/stevex/blog/746669</a></p>
<p>geth --identity &quot;PICC&quot; --rpc --rpccorsdomain &quot;*&quot;  --datadir &quot;%cd%\chain&quot;  --port &quot;30303&quot; --rpcapi &quot;db,eth,net,web3&quot;  --networkid 95518 console</p>
<p>targetgaslimit –每个块的gas上限，这里可以暂时理解为容量 rpc –启动rpc通信，可以进行智能合约的部署和调试 rpcaddr –rpc接口的地址 rpcport –rpc接口的端口号 port –网络监听端口，用于节点之间通信 rpcapi –设置rpc的范围，暂时开启eth,web3,personal足够 networkid –设置当前区块链的网络ID，是一个数字，可以随便写 identity –区块链的标示，随便填写，用于标示目前网络的名字 nodiscover 禁止被网络中其它节点发现，需要手动添加该节点到网络 maxpeers 最大节点数量 datadir –设置当前区块链网络数据存放的位置 unlock –解锁某用户（此处用用户坐标来控制，解锁后的用户调用接口发起交易时，不要需要提供密码） rpccorsdomain 限制rpc访问源的ip，代表不限制 mine 允许挖矿 console –启动命令行模式，可以在Geth中执行命令*</p>
<p>personal.newAccount()</p>
<h2>智能合约</h2>
<p>以太坊很大的特色就是能够实现智能合约，所谓智能合约，是密码学家提出以数字形式定义的一系列承诺，包括合约参与方可以在上面执行这些承诺的协议。</p>
<p>智能合约一旦设立指定后，能够无需中介的参与自动执行，并且没有人可以阻止它的运行。</p>
<p>区块链为智能合约提供可行执行环境，智能合约为区块链扩展应用。而在以太坊上的智能合约，能够控制区块链上各种数字资产进行复杂的操作，随着智能合约开始获得越来越多的使用，人们也发现，就像现实世界的合同一样，如果没有认真审核的话，其中就有可能出现漏洞，并且被坏人利用。</p>
<p><strong>智能合约是什么</strong></p>
<p>从用户角度来讲，智能合约通常被认为是一个自动担保账户，例如，当特定的条件满足时，程序就会释放和转移资金</p>
<p>从技术角度来讲，智能合约被认为是网络服务器，只是这些服务器并不是使用IP地址假设在互联网上，而是架设在区块链上，从而可以在上面运行特定的程序。</p>
<p>但与网络服务器不同的是，所有人都可以看到智能合约，因为这些智能合约的代码和状态都在区块链上。而且，与网络服务器不同的是，智能合约不依赖某个特定的硬件设备，事实上，智能合约的代码由所有参与挖矿的设备来执行</p>
<p>代码的执行是自动的: 要么成功执行，或者所有的状态变化都撤销(包括从当前失败的合约中已经发送或接受的信息) 这很重要，避免了合约 部分执行的情况(例如，在证券购买交易中，证券所有者已经转移发送了证券，但是密码学货币的支付转移却失败了)。 在区块链环境下，这尤为重要，因为没有办法来撤销执行错误所带来的不好的后果(如果对手不配合的话，根本没有办法逆转交易)</p>
<p>智能合约基于区块链的智能合约包括事务处理和保存的机制，以及一个完备的状态机，用于接受和处理各种智能合约；并且事务的保存和状态处理都在区块链上完成。事务主要包含需要发送的数据；而事件则是对这些数据的描述信息。事务及事件信息传入智能合约后，合约资源集合中的资源状态会被更新，进而触发智能合约进行状态机判断。如果自动状态集中某个或某几个动作的触发条件满足，则由状态机根据预设信息选择合约动作自动执行。</p>
<p>基于区块链的智能合约的构建及执行分为如下步骤：</p>
<p>智能合约的构建: 由区块链内的多个用户共同参与指定一份智能合约；</p>
<p>智能合约的存储: 智能合约通过P2P网络扩散到每个节点，并存入区块链</p>
<p>智能合约的执行: 智能合约定期进行自动机状态检查，将满足条件的事务进行验证，达成共识后自动执行并通知用户</p>
<p>智能合约其实就是一种可以自动化执行的简单交易。</p>
<p>https://www.cnblogs.com/fengzhiwu/p/5629468.html</p>
<h2>MetaMask过程</h2>
<h2>Ubuntu上</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/08/Spark-调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Spark-调优/" itemprop="url">Spark 调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-08T17:34:19+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Spark 性能调优记录</h2>
<p>Spark 性能调优要点分析</p>
<pre><code>并行度
压缩
序列化
数据倾斜
JVM调优(JVM数据结构化优化)
内存调优
Task性能调优(包含Mapper和Reducer两种类型的Task)
Shuffle网络优化(小文件合并)
RDD算子优化(RDD复用，自定义RDD)
数据本地性
容错调优
参数调优
</code></pre>
<p>大数据最怕的就是数据本地性和数据倾斜，调优Spark的重点一定是在数据本地性和数据倾斜入手</p>
<pre><code>资源分配和使用: 能够申请多少资源以及如何最优化的使用计算资源
Shuffle调优: 分布式系统必然面临的杀手级别的问题
数据倾斜： 分布式系统业务本身有数据倾斜
</code></pre>
<p>核心调优参数如下</p>
<pre><code>num-executors: 
	Yarn会按照Driver的申请去最终为当前的Application生产指定个数的Executors，
executor-memory:
	定义了每个Executor的内存，与JVM OOM密切相关，许多时候甚至决定了Spark运行的性能
	如果executor-memory超过了worker-memory 就会停止任务
	

executor-cores:
	决定了在Executors中能够并行执行的Tasks的个数

total-executor-cores:
	所有的core的个数，该数目除以executor-cores = executor个数


driver-memory: 默认是1G
spark.default.parallelize: 并行度问题，如果不设置这个参数，Spark会根据HDFS中的Block的个数去设置这一个数量，原理是每个Block对应一个Task，Spark官方的建议是每一个Core负责2-3个Task

spark.storage.memoryFraction: 默认占用60%，如果计算比较依赖历史数据则可以调高该参数，如果计算比较依赖Shuffle的话则需要降低该比例。

spark.shuffle.memoryFraction: 默认占用20%,如果计算比较依赖shuffle的话则需要调高该比例。
</code></pre>
<p>**Spark 更高性能的算子 **</p>
<p>Shuffle分开两部分，一个是Mapper端的Shuffle，另一个就是Reduce端的Shuffle，性能调优有一个很重要的总结就是尽量不使用Shuffle类的算子，能避免就尽量避免，因为一般进行Shuffle的时候，会把集群中多个节点上的同一个key汇聚在同一个节点上，例如reduceByKey。然后会优先把数据放在内存中，但如果内存不够的话会放在磁盘上。Shuffle在进行数据转去之前，为了整个集群的稳定性，它的Mapper端会把数据写到本地文件系统。这可能导致大量磁盘文件的操作。如何避免Shuffle可以考虑如下:</p>
<pre><code>1 采用Map端的Join(RDD1+RDD2) 先把一个RDD1的数据收集起来，然后再通过sc.broadcast()把数据广播到Executor上
2 如果无法避免Shuffle，退而求其次就是需要更多的机器参与Shuffle过程，这个时候就需要充分的利用Mapper端和Reducer端机制的计算资源，尽量使用Mapper端的Aggregate功能，例如aggregateByKey操作。相对于groupByKey而言，更倾向于使用reduceByKey() 和aggregateByKey() 来取代groupByKey(),因为groupbyKey() 不会进行Mapper端的操作，aggregateByKey()可以给予更多的控制。
3 如果一批一批的处理数据来说，可以使用mapPartitions(),但这个算子可能会出现OOM机会，会进行JVM的GC操作。
4 如果进行批量插入数据到数据库的话，建议使用foreachPartition() 
5 
6 官方建议使用repartitionAndSortWithPartitions()
7 数据进行复用时一般都会进行持久化persist()
8 
</code></pre>
<p>Spark开发调优</p>
<p>1 避免创建重复的RDD</p>
<pre><code>对于同一份数据，只应该创建一个RDD，不能创建多个RDD来代表同一份数据
</code></pre>
<p>2 尽可能复用同一个RDD</p>
<pre><code>由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
JavaRDD&lt;String&gt; rdd2 = rdd1.map(...)

rdd1.reduceByKey(...)
rdd2.map(...)

// 上面这个case中，其实rdd1和rdd2的区别无非就是数据格式不同而已，rdd2的数据完全就是rdd1 的子集而已，却创建了两个rdd
可以用一个rdd来执行操作

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
rdd1.reduceByKey(...)
rdd1.map(tuple._2...)
</code></pre>
<p>三: 对多次使用的RDD进行持久化</p>
<pre><code>Spark中对于一个RDD执行多次算子的默认原理是这样的：每次你对一个RDD执行一个算子操作时，都会重新从源头处计算一遍，计算出那个RDD来，然后再对这个RDD执行你的算子操作。这种方式的性能是很差的。

因此对于这种情况，我们的建议是：对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略，将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时，都会直接从内存或磁盘中提取持久化的RDD数据，然后执行算子，而不会从源头处重新计算一遍这个RDD，再执行算子操作。

val rdd1 = sc.textFile(&quot;hdfs://192.168.0.1:9000/hello.txt&quot;).cache()
rdd1.map(...)
rdd1.reduce(...)
</code></pre>
<p>四: 尽量避免使用Shuffle类算子</p>
<pre><code>Shuffle过程中，会发生大量的磁盘文件读写的IO操作，以及数据的网络传输操作。磁盘IO和网络传输也是Shuffle性能较差的主要原因。

// 传统的join操作会导致Shuffle操作
因为在两个RDD中，相同的Key都需要通过网络拉取到一个节点上，由一个task进行join操作。
val rdd3= rdd1.join(rdd2)

// Boradcast + map 的join操作，不会导致shuffle操作
//使用broadcast将一个数据量较小的rdd作为广播变量
val rdd2Data = rdd2.collect()
val rdd2DataBroadCast = sc.broadcast(rdd2Data)
</code></pre>
<p>五: 使用map-side预聚合的shuffle操作</p>
<pre><code>map-side端的操作: 类似于Mapreduce中的本地combiner
map-side 预聚合之后，每个节点就会只有一条相同的key?

建议使用reduceByKey或aggregateByKey算子来替代掉groupByKey算子。因为reduceByKey和aggregateByKey算子都会使用用户自定义的函数对每个节点本地相同的key进行预聚合，而groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间进行分发和传输，性能相对来说会比较差。
</code></pre>
<p><img src="/img/spark1.png" alt="">
<img src="/img/spark2.png" alt=""></p>
<p>六 使用高性能的算子</p>
<pre><code>1 使用groupByKey 替代groupByKey
2 使用mapPartitions 替代普通的map
mapPartitions 类的算子，一次函数调用会处理一个partition所有的数据，而不是一次函数调用处理一条，性能相对来说会高一些。但是有的时候，使用mapPartitions会出现OOM的问题。因为单次函数调用就要处理掉一个partition所有的数据，如果内存不够，垃圾回收时是无法回收掉太多对象的，很可能出现oom异常，所以使用这类操作要慎重。

3 使用foreachParitions替代foreach
也是一次函数调用处理一个partition的所有数据，而不是一条数据。 

实践中发现，


4 使用filter之后进行coalesce操作
通常对一个RDD执行filter算子过滤掉RDD中较多数据后(比如过滤掉30%以上的数据)，建议使用coalesce算子，手动减少RDD的partition数量，将RDD中的数据压缩到更少的partition中去。


5 使用repartitionAndSortWithinPartition替代repartition与sort算子

repartitionAndSortWithinPartitions是Spark官网推荐的一个算子，官方建议，如果需要在repartition重分区之后，还要进行排序，建议直接使用repartitionAndSortWithinPartitions算子。因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。
</code></pre>
<p>七: 广播大变量</p>
<pre><code>在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。

因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。

通过广播方式，将变量的位置从 task 放在了Executor中
用以共享变量
</code></pre>
<p>使用Kryo优化序列化性能</p>
<pre><code>* 在算子函数中使用外部变量时，该变量会被序列化后进行网络传输
* 将自定义的类型作为RDD的泛型类型时(比如JavaRDD，Student是自定义类型)，所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口
* 使用可序列化的持久化策略时，Spark会将RDD中的每个partition都序列化成一个大的字节数组

官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。


// 创建SparkConf对象。
val conf = new SparkConf().setMaster(...).setAppName(...)
// 设置序列化器为KryoSerializer。
conf.set(&quot;spark.serializer&quot;, &quot;org.apache.spark.serializer.KryoSerializer&quot;)
// 注册要序列化的自定义类型。
conf.registerKryoClasses(Array(classOf[MyClass1], classOf[MyClass2]))
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JackNiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackNiu</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
