<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SpeechAndLanguageProcessing">
<meta property="og:url" content="http://niuwenchen.github.io/index.html">
<meta property="og:site_name" content="SpeechAndLanguageProcessing">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpeechAndLanguageProcessing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://niuwenchen.github.io/"/>





  <title>SpeechAndLanguageProcessing</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SpeechAndLanguageProcessing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">translate and learning language model</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/22/frature-importance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/frature-importance/" itemprop="url">frature_importance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T17:06:41+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>GBDT:feature_importance及Spark:feature_importance计算</h2>
<p>参考文档： <a href="http://www.cnblogs.com/yxzfscg/p/5142620.html" target="_blank" rel="noopener">http://www.cnblogs.com/yxzfscg/p/5142620.html</a>,<a href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/tree/_tree.pyx" target="_blank" rel="noopener">https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/tree/_tree.pyx</a></p>
<p>GBDT其底层实现就是决策树，因此，feature_importance其实现即为GBDT实现。</p>
<p>主要代码</p>
<pre><code>importance_data[node.feature] += (
                    node.weighted_n_node_samples * node.impurity -
                    left.weighted_n_node_samples * left.impurity -
right.weighted_n_node_samples * right.impurity)
</code></pre>
<p>采用iris数据源进行验证说明</p>
<pre><code>from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
iris = load_iris()
X = iris.data
y = iris.target
print(X[0])
dt = DecisionTreeClassifier(criterion='gini')
dt.fit(X, y)
print(dt.feature_importances_)

from sklearn.tree import export_graphviz
with open('feature_tree.dot','w')as f:
	f=export_graphviz(dt)
</code></pre>
<p>生成决策树模型：</p>
<pre><code>采用该命令： dot -Tpdf  tree.dot -o tree.pdf
</code></pre>
<p><img src="/img/fea_01.png" alt=""></p>
<pre><code>输出feature_importance: [ 0.02666667  0.          0.05072262  0.92261071]
</code></pre>
<p>验证过程：
从树顶部开始：</p>
<p><img src="/img/fea_02.png" alt=""></p>
<p>上面三者之和近似100(100.005),则特征重要性可以得出。</p>
<p>上面的过程不涉及树的权重，因为只有一颗树，如果类似GBDT这样的多棵树就要加上每棵树的权重。真正的代码实现如下：</p>
<pre><code>total_sum = np.zeros((self.n_features, ), dtype=np.float64)
    for stage in self.estimators_:
        stage_sum = sum(tree.feature_importances_
                        for tree in stage) / len(stage)
        total_sum += stage_sum

    importances = total_sum / len(self.estimators_)
    return importances
</code></pre>
<p>在一些地方加上打印过程，具体如下：</p>
<pre><code>	[ 0.08026236  0.          0.32461037  0.          0.          0.55035696
	0.04477031  0.        ]
	stage_sum 0.0802623563677
	total_sum 0.0802623563677
	[ 0.          0.          0.25505309  0.1419576   0.          0.40878994
	0.19419937  0.        ]
	stage_sum 0.0
	total_sum 0.0802623563677
	[ 0.07849338  0.          0.35527078  0.          0.          0.56623584
	0.          0.        ]
	stage_sum 0.0784933756874
	total_sum 0.158755732055
	[ 0.          0.          0.26975468  0.08468996  0.          0.41409671  0.23145865  0.        ]
	stage_sum 0.0
	total_sum 0.158755732055
	[ 0.08331287  0.          0.25748023  0.07290349  0.          0.37375141 0.212552    0.        ]
	stage_sum 0.0833128747713
	total_sum 0.242068606826
	total_sum / len(self.estimators_) [ 0.04841372  0.          0.29243383  0.05991021  0.          0.46264617
	0.13659606  0.        ]
	feature_importance_ [ 0.04841372  0.          0.29243383  0.05991021  0.          0.46264617
	0.13659606  0.        ]
</code></pre>
<p>简单来说，就是叠加每一棵树的对应特征的feature_importance_,然后除以总的树棵树，就是所得的feature_importance,并没有添加对应的weight。</p>
<p>这应该就是python和spark的不同之处，python注重每棵树的特性，而spark注重整棵树的特性，整棵树的weight是能够得到的，但是无法计算出特征重要性。</p>
<p>因此，计算spark 的feature_importance 可以用spark生成的树来计算每个节点的gini系数，然后按照上述计算过程计算importance。采用倒推的方式进行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning-02/" itemprop="url">Ensemble Learning 02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T19:13:09+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Boosting</h2>
<h2>2.2 Boostrapping and Bagging</h2>
<p>有放回的抽样，每一个数据不被选中的概率是 0.368
<img src="/img/ens2_1.png" alt=""></p>
<p>boostrapping</p>
<p><img src="/img/ens2_2.png" alt="">
	样本集是N个样本，随机选择N个，选择B次，得出B个学习器
	计算boostrap estimate 和accuracy</p>
<p>Bagging(bootstrap aggregation自举汇聚法)</p>
<p><img src="/img/ens2_3.png" alt=""></p>
<pre><code>bagging
* increases classifier stability and accuracy
* reduce classifier variance,in terms of the bias-variance decomposition
</code></pre>
<p><img src="/img/ens2_4.png" alt=""></p>
<p>BaggingClassifier分析</p>
<pre><code>class sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=1, random_state=None, verbose=0)

base_estimator: 弱分类器
n_estimators: 弱分类器个数
max_sample: 弱分类器训练样本数，
max_features: 弱分类器训练样本特征数目
bootstrap: 是否是有放回抽样  True
bootstrap_features: 特征是否是有放回 False
oob_score:是否使用袋外数据去估计错误率
warm_start: 
n_jobs: 并行计算
random_state: 
verbose: 冗长

base_estimator_ : estimator
estimators_ : list of estimators
estimators_samples_ : list of arrays
estimators_features_ : list of arrays
classes_ : array of shape = [n_classes]
n_classes_ : int or list
oob_score_ : float
oob_decision_function_
</code></pre>
<h2>Boosting Algorithms</h2>
<p>无放回采样</p>
<p><img src="/img/ens2_5.png" alt=""></p>
<p><img src="/img/ens2_6.png" alt=""></p>
<h2>AdaBoost Algorithm</h2>
<p>ada训练注重的是每个样本的样本权重，
<img src="/img/ens2_7.png" alt=""></p>
<p><img src="/img/ens2_8.png" alt=""></p>
<p>第四行的h是一个阶跃函数，x&gt;0,y=1,x&lt;0,y=0;</p>
<p>这里的一个点就是弱分类器h的确定。</p>
<p>algorithm：这个参数只有AdaBoostClassifier有。主要原因是scikit-learn实现了两种Adaboost分类算法，SAMME和SAMME.R。两者的主要区别是弱学习器权重的度量，SAMME使用了和我们的原理篇里二元分类Adaboost算法的扩展，即用对样本集分类效果作为弱学习器权重，而SAMME.R使用了对样本集分类的预测概率大小来作为弱学习器权重。由于SAMME.R使用了概率度量的连续值，迭代一般比SAMME快，因此AdaBoostClassifier的默认算法algorithm的值也是SAMME.R。我们一般使用默认的SAMME.R就够了，但是要注意的是使用了SAMME.R， 则弱分类学习器参数base_estimator必须限制使用支持概率预测的分类器。SAMME算法则没有这个限制。</p>
<p>下面进行一个尝试:基于单层决策树构建弱分类器</p>
<pre><code>单层决策树(决策树桩)是一种简单的决策树: 仅仅基于单个特征来做决策。由于这棵树只有一次分裂过程，实际上就是一个树桩。
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning-01/" itemprop="url">Ensemble Learning 01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T17:13:37+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Ensemble Learning</h2>
<h3>介绍</h3>
<p>集成学习： reduce variabce -- impoove accuracy</p>
<h2>1.1.1</h2>
<p>所有的分类器错误都可以被归结为两类:</p>
<pre><code>bias: 分类器的准确性
variance: 在不同训练集上训练时 分类器的精度
趋势关系: 分类器有低bias 那么则倾向于高的variance
vice versa: 反之亦然。
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Ensemble-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Ensemble-Learning/" itemprop="url">Ensemble Learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T13:07:05+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>集成学习</h2>
<p>继承学习中的误差(方差与偏差)</p>
<p>任何模型中出现的误差都可以被拆解为三个要素</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/Wb6I0AHP.png" alt=""></p>
<p>偏差Bias Error: 量化预测值与实际值差异的均值(期望)。高偏差的出现表示模型遗漏了重要的变化趋势，就是说这个模型表现并不乐观</p>
<p>方差Variance: 个体预测结果离散程度的量化，一个拥有过大方差的模型将会对训练总体过度的拟合，从而无法保证对训练集外的个体进行准确的预测。</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/6UBxj3Rg.png" alt=""></p>
<p>需要注意的点: 通常情况下，你会发现偏差的降低会导致模型总误差的减小，但当过了某个特定的点之后，再增加模型的复杂度则会适得其反。最终，你的模型将面临过度拟合的问题，并且具有了较高的方差</p>
<p>理论上，最优的模型应该做到尽量保持偏差和方差的的均衡。</p>
<p><img src="http://static.datartisan.com/upload/attachment/2015/08/Ugj1NJBn.png" alt=""></p>
<p>Bagging</p>
<p>bagging 在小数据集上实现相似的学习器然后取所有预测的均值。一般的bagging中，可以使用不同的学习器在不同的样本中。</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2015/07/bagging.png" alt=""></p>
<p>Boosting</p>
<p>Boosting是一种迭代算法，能根据最后一个分类的预测情况来调整观测值的权重。如果一个观测值的分类被预测错误，那么该算法将增加这个观测值的权重，否则反之。通常情况下，Boosting能有效减少偏差并构建出有效的模型，同时也面临着拟合的风险。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Solidity-Localtion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Solidity-Localtion/" itemprop="url">Solidity Localtion </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T11:18:46+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Location</h2>
<pre><code>pragma solidity ^0.4.9;

contract Loc1{
struct S{string a;uint b;}

//parameter is memory
function assign(S s) internal{
    // local variable is storage
    S memory tmp =s;
}
}
</code></pre>
<p>// convert storage to storage</p>
<pre><code>contract Loc2{
struct S{string a;uint b;}

S s;

function convertToStorage(S storage  s) internal{
    S tmp =s;
    tmp.a = &quot;Test&quot;;
}
function call()  constant returns  (string str)
{
    convertToStorage(s);
    return s.a; //Test
}
}
</code></pre>
<p>// memory to state variable</p>
<pre><code>contract Loc3{
struct S{string a;uint b;}

S s;

function memoryToState(S memory tmp) internal{
    s = tmp;
    tmp.a =&quot;Test&quot;;
}
function call() constant returns (string)
{
    S memory tmp = S(&quot;memory&quot;,0);
    memoryToState(tmp);
    return s.a;
}
}
</code></pre>
<p>// memory to Local variable</p>
<pre><code>contract Loc4 {
struct S{string a;uint b;}
function memoryToLocal(S s) internal{
    // Error
    // S tmp =s;
    S memory tmp =s;
}
}
</code></pre>
<p>// storage to memory</p>
<pre><code>contract Loc5{
struct S{string a;uint b;}

// storage variable
S s= S(&quot;storage&quot;,1);

function storageToMemory(S storage x) internal{
    // storage to memory
    S memory tmp= x;
    tmp.a = &quot;Text&quot;;
}
function call() constant returns (string){
    storageToMemory(s);
    return s.a;
}
}


contract Loc6{
struct S{string a;uint b;}

function memoryToMemory(S s ) internal{
    S memory tmp =s;
    tmp.a = &quot;other memory&quot;;
}
function call() constant returns (string)
{
    S memory mem = S(&quot;memory&quot;,1);
    memoryToMemory(mem);
    return mem.a;
}
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/21/Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Spark/" itemprop="url">Spark</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-21T10:40:23+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/15/solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/solidity/" itemprop="url">solidity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-15T13:44:07+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Solidity Tutorials</h2>
<pre><code>pragma solidity ^0.4.9;

contract SimpleStorage {
uint data;

function setData(uint x) public{
    
    data = x;
}

function getData() public constant returns (uint)  {
    
    return data;
}
}
</code></pre>
<h2>使用Truffle 部署测试协议</h2>
<pre><code>mkdir hello-world
cd hello-world
truffle init

truffle test

...
</code></pre>
<p>建立协议</p>
<pre><code>truffle create contract HelloWorld
contracts/HelloWorld.sol

pragma solidity ^0.4.9;

contract HelloWorld {
address private creator;
address private lastCaller;
string private message;
uint private totalGas;



function HelloWorld(){
     /*
  We can use the special variable `tx` which gives us information
  about the current transaction.

  `tx.origin` returns the sender of the transaction.
  `tx.gasprice` returns how much we pay for the transaction
	*/
    creator = tx.origin;
    totalGas = tx.gasprice;
    message = &quot;Hello World&quot;;
}

function getMesage() constant returns (string) {
    return message;
}

function getLastCaller() constant returns(address){
    return lastCaller;
}
function getCreator() constant returns (address){
    return creator;
}
function getTotalGas() constant returns(uint) {
return totalGas;
}
//End: getters

//Being: setters
function setMessage(string newMessage) {
message = newMessage;
lastCaller = tx.origin;
totalGas += tx.gasprice;
}
}
</code></pre>
<p>Migration:我们完成了一个协议，需要用一种方式将这个协议部署到区块链中。truffle使用migration方式，压缩和部署contracts</p>
<pre><code>truffle create migration 
生成一个文件: 1521178244_deploy_hello_world.js

在js文件中部署协议

const HelloWorld = artifacts.require('HelloWorld')
	module.exports = function(deployer) {
deployer.deploy(HelloWorld)
};
</code></pre>
<p>需要将协议部署到测试区块链中  truffle migrate --reset</p>
<p>Testing</p>
<pre><code>truffle create test HelloWorld
test/hello_world.js

const HelloWorld = artifacts.require('HelloWorld')

contract('HelloWorld', function(accounts) {
it('sets the first account as the contract creator', async function() {
		const contract = await HelloWorld.deployed()
		const creator = await contract.getCreator()
		
		assert.equal(creator, accounts[0],'main account is the creator')
})
it('has hello world as initial message' ,async function(){
				const contract = await HelloWorld.deployed()
				
				const message = await contract.getMesage()
				assert.equal(message, 'Hello World', 'message is hola mundo')
		})
it('changes the message via setMessage', async function() {
const contract = await HelloWorld.deployed()

// Execute a transaction and change the state of the contract.
await contract.setMessage('hola mundo')

// Get the new state.
const message = await contract.getMesage()

assert.equal(message, 'hola mundo', 'message is hola mundo')
})
});
</code></pre>
<p>使用测试命令</p>
<pre><code>truffle test
测试输出

Contract: HelloWorld
√ sets the first account as the contract creator
√ has hello world as initial message
√ changes the message via setMessage (91ms)
</code></pre>
<p>解析这个过程 <a href="https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/" target="_blank" rel="noopener">https://blog.abuiles.com/blog/2017/07/08/writing-smart-contracts-with-truffle/</a></p>
<p>1 协议文件</p>
<pre><code>构造函数中一个变量tx

首先看下面的全局变量

block.coinbase(address): 当前块的矿场的地址
block.difficulty(uint) : 当前块的难度
block.gaslimit(uint)   : 当前块的gaslimit
block.number(uint)     : 当前块的数量
block.blockhash(function(uint) returns(bytes32)): 给定的块的hash值，只有最近工作的256块的hash值
block.timestamp(uint)  ： 当前块的时间戳
msg.data(bytes)			: 完整的calldata
msg.gas(uint)			: 剩余gas
msg.sender(address)		: 消息的发送者
msg.value(uint)			: 和消息一起发送的wei的数量
now(uint):				当前块的时间戳(block.timestamp的别名)
tx.gasprice(uint):		交易的gas价格
tx.origin(address):		交易的发送者(全调用链)
sha3(...) retuens (bytes32): 计算(紧凑排列的) 参数的 Etherum-SHA3 hash值
sha256(...) returns (bytes32): 计算(紧凑排列的)参数的SHA256 hash值
ripemd160(...) returns (bytes20): 计算256个参数的RIPEMD
ecrecover(bytes32, uint8, bytes32, bytes32) returns (address):椭圆曲线签名公钥恢复
addmod(uint x, uint y, uint k) returns (uint):计算（x + y）K，加法为任意精度，不以2 ** 256取余
mulmod(uint x, uint y, uint k) returns (uint):计算（XY）K，乘法为任意精度，不以2 * 256取余
this (current contract’s type): 当前合约，在地址上显式转换
super:在层次关系上一层的合约
selfdestruct(address):销毁当前的合同，将其资金发送到指定address地址
.balance:address地址中的账户余额（以wei为单位）
.send(uint256) returns (bool):将一定量wei发送给address地址，若失败返回false。
</code></pre>
<p>contract中的分析</p>
<pre><code>creator = tx.origin;  //交易的发送者，协议的关联者，
这里和第一个account账户关联
totalGas = tx.gasprice;
message = &quot;Hello World&quot;;

const contract = await HelloWorld.deployed()
const creator = await contract.getCreator()
console.log(creator)
console.log(accounts[0])

0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278

tx.gasprice: BigNumber { s: 1, e: 11, c: [ 100000000000 ] }

也就是在部署这个协议的时候，默认将accounts作为tx.origin，那么协议的发送者是谁?
并且会调用构造函数

tx.origin: 0x0eb84a8d7ae082e0d9709c75ba8a230e0c74e278
</code></pre>
<p>下面修改协议，对上面的数据进行一次重新测试</p>
<pre><code>    coinbase = block.coinbase();
    difficulty = block.difficulty();
    gaslimit = block.gaslimit();
    number = block.number();
    nottime = block.timestamp();
    calldata = msg.data();
    gas = msg.gas();
    sender = msg.sender();
    weivalue = msg.value();
</code></pre>
<p><img src="/img/solidity01.png" alt=""></p>
<h2>Solidity by Example</h2>
<p><strong>Voting</strong></p>
<p>how to assign voting rights to the correct persons and how to prevent manipulation.</p>
<pre><code>pragma solidity ^0.4.9;


contract Ballot {
// struct type
struct Voter{
    uint weight;
    bool voted;
    address delegate;
    uint vote;
}

struct Proposal{
    bytes32 name;
    uint voteCount;
}

address public chairperson;
mapping(address =&gt; Voter) public voters;
Proposal[] public proposals;


function Ballot(bytes32[] proposalNames) public {
    chairperson = msg.sender;
    voters[chairperson].weight =1;

    for(uint i=0;i&lt;proposalNames.length;i++)
    {
        proposals.push(Proposal({
            name: proposalNames[i],
            voteCount:0
    }));
    }
}
// Give `voter` the right to vote on this ballot.
// May only be called by `chairperson`.
function giveRightToVote(address voter) public {
    //If the arguments of 'require' evaluate to 'false'
    // it terminates and reverts all changes to
    // the state and to Ether balances. It is often
    // a good idea to use this functions are called incorrectly.proposals//
    // but watch out,this will currently also consume all provided gas
    //(this is planned to change in the future)
    require(
        (msg.sender == chairperson) &amp;&amp;
         !voters[voter].voted &amp;&amp; (voters[voter].weight ==0)
        );
    voters[voter].weight =1;
}

function delegate(address to) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);

    require(to != msg.sender);

    while( voters[to].delegate != address(0))
    {
        to = voters[to].delegate;
        require(to != msg.sender);
    }
    sender.voted = true;
    sender.delegate = to;
    Voter storage delegate_ = voters[to];
    if(delegate_.voted){
        proposals[delegate_.vote].voteCount += sender.weight;
    }else{
        delegate_.weight += sender.weight;
    }

}

function vote(uint proposal) public {
    Voter storage sender = voters[msg.sender];
    require(!sender.voted);
    sender.voted = true;
    sender.vote = proposal;

    proposals[proposal].voteCount += sender.weight;
}

function winningProposal() public view returns (uint winningProposal_)
{
    uint winningVoteCount =0;
    for(uint p=0; p&lt;proposals.length; p++)
    {
        if (proposals[p].voteCount &gt;winningVoteCount){
            winningVoteCount = proposals[p].voteCount;
            winningProposal_ =p;
        }
    }
}

function winnerName() public view returns (bytes32 winnerName_)
{
    winnerName_ = proposals[winningProposal()].name;
}
}

构造函数:
合约的构造者拥有 weight =1
候选人数组: name, 票数 0

giveRightToVote(address voter)
	赋予投票人的投票权利，首先保证合约的拥有者 是主席
	投票者 没有投过票， 权力是0，才能赋予投票权

delegate: 将自己的投票权限给代理人，让代理人帮助投票
	

协议稍微有点复杂，但还是看完了，里面有个问题
一: 测试的时候  [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]作为议案，供用户投票
二: giveRightToVote: 可以输入 1，2，3等值，作为voter账户，
初始化的时候会将bool初始化为false，uint为0，address 为0
三： delegate代理，这个代理的入参是address to，但是这个动作
的发起者是msg.sender,在测试的时候是和create的账户保持一致
的，作为A，然后to作为B，把A的投票权限让B去代理，那么最终的实
际操作在B中，但是也就意味着这样无法完成下面的vote操作，因为
vote操作需要的是msg.sender的投票权限，怎么才能切换用户或者
address，或者msg.sender从而实现不同用户的切换
</code></pre>
<h2>Blind Auction(暗箱拍卖)</h2>
<p>这是一个非公开的拍卖系统，在透明的平台运行非公开拍卖看起来是矛盾的，但是密码学可以做到这一点。</p>
<p>在拍卖期间，参与者把自己的出价加密发送给拍卖系统，除了自己，任何人不知道出价是多少。当拍卖结束，参与者把出价明文发给拍卖系统，系统用明文加密运算，跟之前发送的密文比对，一致的话说明出价跟之前一样，出价有效。</p>
<p>在传统领域，很多业务很容易产生暗箱操作，智能合约让参与者跟工作人员都无法干预系统，系统也没有人的行为，全部是自动执行的代码，使业务变得透明公平，这对产业的变革是颠覆性的。</p>
<h2>Lauout of a Solidity Source File</h2>
<p>pragma  0.x.0  x.0.0</p>
<pre><code>pragma solidity ^0.4.21
</code></pre>
<p>这样一个源文件将不会被低于0.4.0 的编译器编译，或者高于0.5.0 的编译器编译。^ 代表直到0.5.0 之前的编译器都可以编译</p>
<p>导入其他文件</p>
<pre><code>import &quot;filename&quot;;
import * as symbolName from &quot;filename&quot;;
</code></pre>
<p>Paths</p>
<p>注释</p>
<pre><code>pragma solidity ^0.4.0;

/** @title Shape calculator. */
contract shapeCalculator {
/** @dev Calculates a rectangle's surface and perimeter.
  * @param w Width of the rectangle.
  * @param h Height of the rectangle.
  * @return s The calculated surface.
  * @return p The calculated perimeter.
  */
function rectangle(uint w, uint h) returns (uint s, uint p) {
    s = w * h;
    p = 2 * (w + h);
}
}	
</code></pre>
<h2>Structure of a Contract</h2>
<p>State Variables</p>
<pre><code>uint storedData;  // state variable
</code></pre>
<p>Functions</p>
<pre><code>function bid() public payable // function
</code></pre>
<p>Function Modifiers</p>
<pre><code>函数修饰符可以用声明的方式修改函数的语义。

modifier onlySeller() // Modifier
</code></pre>
<p>Events</p>
<pre><code>event HighestBidIncreased(address bidder,uint amount) // Event
</code></pre>
<p>Struct Types</p>
<pre><code>struct Voter{
		uint weight;
		bool voted;
	}  // Struct
</code></pre>
<p>Enum Types //枚举</p>
<pre><code>enum State { Created,Locked,Inactive } // enum
</code></pre>
<h2>Types</h2>
<pre><code>bool: true/false  !, &amp;&amp;, ||, == ,!=
int/uint: uint--&gt; uint 256, int --&gt;int256
&lt;=, &lt; ==,!=,&gt;=, &gt;
位运算: &amp;，| ^ 
&lt;&lt; 左移，  &gt;&gt; 右移
</code></pre>
<p>address: 20 byte value</p>
<pre><code>Members of Addresses: balance and transfer
balance: 查询地址的余额
transfer: 发送Ether(wei 计数) 

address x = 0x123;
address myAddress = this;
if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 

send：
	使用send的时候有些危险，如果call stack depth是1024，或者接收者运行超出gas，交易失败。因此为了交易的安全，检查使用send的返回值； 使用transfer更安全: 或者使用一个方式 接收者撤回money

call,callcode,delegatecall
</code></pre>
<p>Fixed-size Bytes</p>
<pre><code>bytes1,bytes2,bytes3,....bytes32, byte 是bytes1的别名

it is possible to use n array of bytes as byte[], but
is is wasting a lot of space.,31 bytes every element, 
to be exact, when passing in calls, it is better to use bytes
</code></pre>
<p>Dynamically-sized byte array</p>
<pre><code>bytes: 是一个可变长的数组，不是一个value-type
string: 动态可变长的UTF-8编码的字符串。
</code></pre>
<p>Address Literals (地址常量)</p>
<p>Rational and Integer Literals</p>
<p>String Literals</p>
<p>Hexadecimal Literals</p>
<p>Enums</p>
<pre><code>	enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
	ActionChoices choice;
	ActionChoices constant defaultChoice = ActionChoices.GoStraight;
</code></pre>
<p>Function Types</p>
<pre><code>function (&lt;parameter types&gt;) {internal|external} [pure|constant|view|payable] [returns (&lt;return types&gt;)]

默认情况下，函数是内部的，因此，internal可以忽略

function f() public view returns (bytes4) {
	return this.f.selector;
}


//外部函数不能在内部调用
function Pyramid(uint l) public pure returns (uint){
    return ArrayUtils.range(l).map(square).reduce(sum);
}
function square(uint x) external pure returns (uint)
{
    return x*x;
}
function sum(uint x,uint y) external pure returns (uint)
{
    return x+y;
}
因此上面的句子编译失败
</code></pre>
<p>功能修饰符</p>
<pre><code>修饰符可用于轻松更改功能的行为，例如，可以在执行功能之前自动检查条件。修饰符是合同的可继承属性，可能会被派生合同覆盖。

//此合约仅定义修饰符，但不是用它 - 它将用于派生合约
//函数体插入其中，特殊符号 _; 在修饰符的定义出现。
//这意味着如果所有者调用此函数，则执行该函数，否则抛出异常。
modifier onlyOwner{
	require(msg.sender == owner; )
	-;
}
</code></pre>
<p>Reference Types （引用类型）</p>
<pre><code>因为变量间的复制开销比较大，因此一般可以考虑存储在memoey或者storage中

默认的 对于函数参数(包括返回值)是在memory中，本地变量是在storage中
state variables 强制被存储在storage中

还有第三个数据位置，calldata，是一个不能被修改的，不能被持久化的位置，并且函数参数被存储。函数参数被强制性的存储在calldata中。
</code></pre>
<p>数据位置非常重要，因为它们改变了赋值的行为：存储和内存之间的赋值以及状态变量（甚至来自其他状态变量）总是创建一个独立的副本。对本地存储变量的赋值只分配一个引用，而这个引用总是指向状态变量，即使后者在这期间也被改变了。另一方面，从内存存储引用类型到另一个内存存储引用类型的赋值不会创建副本。</p>
<pre><code>uint[] x; // 本地变量存储在storage中
function f(uint[] memorArray)： 函数参数保存在memory中
x=memoryArray; 复制一份memory中的数据到storage中。

var y=x;// 本地变量的赋值是分配一个指向storage的引用
y.length=2; //通过修改引用的大小类修改实际存储对象
delete x;  修改storage中的数据
y=memoryArray; // 不能给一个指针变量赋值一个memory变量。
</code></pre>
<h2>分析</h2>
<p>局部变量是函数中声明的变量，状态变量是合约内声明的共有变量</p>
<p>1 storage 转换为storage</p>
<pre><code>当把一个storage类型的变量赋值给另一个storage时，只是修改了指针
S s; // storage
funciton convertToStorage(S storage s) internal{
	S tmp =s;  // storage  --&gt; storage
	tmp a =&quot;Test&quot;;
}
function call() returns (string)
{
	convertToStorage(s);
	return s.a;//  Test
}
将传入的storage变量，赋值给另一个storage变量，并修改值，最后发现合约的状态变量s也被改变了， 引用的作用
</code></pre>
<p>memory转换为storage</p>
<pre><code>因为局部变来那个和状态变量的类型都可能是storage，分开来讲
</code></pre>
<p>memory赋值给状态变量(原来memory的值是直接可以拷贝给storage的状态变量的，而不能拷贝给局部变量)</p>
<pre><code>将一个memory类型的变量赋值给一个状态变量时，实际上是将内存变量拷贝到存储中

S s;  // storage
function call() returns(string){
	S memry tmp = S(&quot;memory&quot;,0);
	memoryToState(tmp);
	return s.a;
}
function memoryToState(S memory tmp) internal{
	s= tmp;
	tmp.a =&quot;Test&quot;;
}
memory --&gt; 状态变量，是值拷贝
</code></pre>
<p>memory赋值给局部变量</p>
<pre><code>由于在区块链中，storage必须是静态分配存储空间的。局部变量虽然是一个storage的，但是仅仅是一个storage类型的指针。如果进行这样的赋值，会产生错误。

S tmp=s;  是错误的
</code></pre>
<p>storage到memory， 也是值的拷贝，注意storage到memory只需要强制定义左边的类型， 是可以转换成功的。</p>
<p>memory 到memory: memory 之间是引用传递，不是值传递</p>
<p>Arrays</p>
<pre><code>bytes 和string 是特殊的数组，bytes和byte[] 比较详细，但是是稠密的。
</code></pre>
<p>将数组保存在Memory中</p>
<pre><code>将数组变量保存在内存中可以使用new关键字，和保存在storage中相比，不能通过.length 重新划分memory数组长度
</code></pre>
<p>Array Literals/Inline Arrays</p>
<pre><code>数组常量 作为一个表达式 并且不需要马上赋值
function g(uint[3] _data) public pure{
}
则传入参数的形式是
g([uint(1),2,3]);
数组常量是一个memory数组，长度固定，基本类型是给定数据的普遍类型，[1,2,3]是uint8[3] memory,因为每一个元素的类型是uint8,因此，需要将第一个类型转换为uint。注意，固定长度的memory数组不能被分配给动态长度的memory数组。

也就是说 uint[] x= [uint(1),3,4]是不行的，后面的是固定长度的，前面的是可变长度的。uint[] x 是一个storage变量。

uint[] memory  x=new uint[](3)
 x = [uint(3),3,4]
Type uint256[3] memory is not implicitly convertible to expected type uint256[] memory.
后面的是固定长度的数组，前面的是可变长的数组，不能赋值?
有点奇怪
</code></pre>
<p>Members</p>
<pre><code>length: 动态数组可以在storage(不是在memory)中调整大小通过.length 

那么动态数组应该如何定义呢?
uint[] x = new uint[](4)
TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] storage pointer

push: 动态stoeage 数组和bytes 有一个函数push，可以用来追加一个新的元素在数组的末尾。 函数返回一个新的长度
</code></pre>
<p>Structs</p>
<p>Mappings</p>
<p>delete</p>
<pre><code>delete a 恢复初始值。 数组的话是长度为0
</code></pre>
<p>Conversions between Elementary Types</p>
<p>货币单位(Ether Units)</p>
<p>一个字面量的数字，可以使用后缀wei,finney,szabo或ether来在不同面额中转换。不含任何后缀的默认单位是wei。如2 ether == 2000 finney的结果是true。</p>
<pre><code>（2 ether == 2000 finney）
</code></pre>
<p>时间单位</p>
<pre><code>seconds,minutes,hours,days,weeks,years
1== 1 secondes
1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours 
1 weeks == 7 dyas
1 years == 365 dyas
</code></pre>
<p>Error Handling</p>
<pre><code>assert(bool condition): 如果条件不满足则抛出异常
require(bool condition):
revert(): abort execution and revert state changes
</code></pre>
<p>数学公式</p>
<pre><code>addmod(uint x,uint y,uint k) returns (uint)
	(x+y)%k
keccak256(...) returns (bytes32)
	compute the etherum-ShA03 hash of the arguments
keccak256(12)
	0x4de0e96b0a8886e42a2c35b57df8a9d58a93b5bff655bc37a30e2ab8e29dc066

sha256
sha3 == keccak256
</code></pre>
<p>地址相关</p>
<pre><code>&lt;address&gt;.balance  Wei
&lt;adderss&gt;.transfer()
		 . send
		 .call
		 .callcode
		 .delegatecall
</code></pre>
<p>协议相关的</p>
<pre><code>this(current contract's type)
selddestruct(address recipient)
	销毁当前合约，将他的funds发送给指定地址
suicide(address recipient)
	过时了，是selfdestruct的别称
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/12/区块链01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/区块链01/" itemprop="url">区块链01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-12T13:06:57+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Windows</h2>
<p><a href="https://github.com/ethereum/go-ethereum/releases/" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/</a></p>
<p>安装后用cmd命令打开命令行，进入到你安装geth的目录下，输入geth –help 命令，如果输出一大堆关于geth的信息如下图则说明安装成功。当前geth命令只能在geth对应的目录下使用，如果想要在任何目录使用geth命令，只要把你安装geth的目录的路径加入到系统环境环境变量path中即可。</p>
<p><a href="https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/tag/v1.4.11</a></p>
<p><a href="https://ethereum.github.io/go-ethereum/downloads/" target="_blank" rel="noopener">https://ethereum.github.io/go-ethereum/downloads/</a>
最全的下载地址</p>
<p>创世文件的定义
<a href="https://my.oschina.net/stevex/blog/746669" target="_blank" rel="noopener">https://my.oschina.net/stevex/blog/746669</a></p>
<p>geth --identity &quot;PICC&quot; --rpc --rpccorsdomain &quot;*&quot;  --datadir &quot;%cd%\chain&quot;  --port &quot;30303&quot; --rpcapi &quot;db,eth,net,web3&quot;  --networkid 95518 console</p>
<p>targetgaslimit –每个块的gas上限，这里可以暂时理解为容量 rpc –启动rpc通信，可以进行智能合约的部署和调试 rpcaddr –rpc接口的地址 rpcport –rpc接口的端口号 port –网络监听端口，用于节点之间通信 rpcapi –设置rpc的范围，暂时开启eth,web3,personal足够 networkid –设置当前区块链的网络ID，是一个数字，可以随便写 identity –区块链的标示，随便填写，用于标示目前网络的名字 nodiscover 禁止被网络中其它节点发现，需要手动添加该节点到网络 maxpeers 最大节点数量 datadir –设置当前区块链网络数据存放的位置 unlock –解锁某用户（此处用用户坐标来控制，解锁后的用户调用接口发起交易时，不要需要提供密码） rpccorsdomain 限制rpc访问源的ip，代表不限制 mine 允许挖矿 console –启动命令行模式，可以在Geth中执行命令*</p>
<p>personal.newAccount()</p>
<h2>智能合约</h2>
<p>以太坊很大的特色就是能够实现智能合约，所谓智能合约，是密码学家提出以数字形式定义的一系列承诺，包括合约参与方可以在上面执行这些承诺的协议。</p>
<p>智能合约一旦设立指定后，能够无需中介的参与自动执行，并且没有人可以阻止它的运行。</p>
<p>区块链为智能合约提供可行执行环境，智能合约为区块链扩展应用。而在以太坊上的智能合约，能够控制区块链上各种数字资产进行复杂的操作，随着智能合约开始获得越来越多的使用，人们也发现，就像现实世界的合同一样，如果没有认真审核的话，其中就有可能出现漏洞，并且被坏人利用。</p>
<p><strong>智能合约是什么</strong></p>
<p>从用户角度来讲，智能合约通常被认为是一个自动担保账户，例如，当特定的条件满足时，程序就会释放和转移资金</p>
<p>从技术角度来讲，智能合约被认为是网络服务器，只是这些服务器并不是使用IP地址假设在互联网上，而是架设在区块链上，从而可以在上面运行特定的程序。</p>
<p>但与网络服务器不同的是，所有人都可以看到智能合约，因为这些智能合约的代码和状态都在区块链上。而且，与网络服务器不同的是，智能合约不依赖某个特定的硬件设备，事实上，智能合约的代码由所有参与挖矿的设备来执行</p>
<p>代码的执行是自动的: 要么成功执行，或者所有的状态变化都撤销(包括从当前失败的合约中已经发送或接受的信息) 这很重要，避免了合约 部分执行的情况(例如，在证券购买交易中，证券所有者已经转移发送了证券，但是密码学货币的支付转移却失败了)。 在区块链环境下，这尤为重要，因为没有办法来撤销执行错误所带来的不好的后果(如果对手不配合的话，根本没有办法逆转交易)</p>
<p>智能合约基于区块链的智能合约包括事务处理和保存的机制，以及一个完备的状态机，用于接受和处理各种智能合约；并且事务的保存和状态处理都在区块链上完成。事务主要包含需要发送的数据；而事件则是对这些数据的描述信息。事务及事件信息传入智能合约后，合约资源集合中的资源状态会被更新，进而触发智能合约进行状态机判断。如果自动状态集中某个或某几个动作的触发条件满足，则由状态机根据预设信息选择合约动作自动执行。</p>
<p>基于区块链的智能合约的构建及执行分为如下步骤：</p>
<p>智能合约的构建: 由区块链内的多个用户共同参与指定一份智能合约；</p>
<p>智能合约的存储: 智能合约通过P2P网络扩散到每个节点，并存入区块链</p>
<p>智能合约的执行: 智能合约定期进行自动机状态检查，将满足条件的事务进行验证，达成共识后自动执行并通知用户</p>
<p>智能合约其实就是一种可以自动化执行的简单交易。</p>
<p>https://www.cnblogs.com/fengzhiwu/p/5629468.html</p>
<h2>MetaMask过程</h2>
<h2>Ubuntu上</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/08/Spark-调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Spark-调优/" itemprop="url">Spark 调优</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-08T17:34:19+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Spark 性能调优记录</h2>
<p>Spark 性能调优要点分析</p>
<pre><code>并行度
压缩
序列化
数据倾斜
JVM调优(JVM数据结构化优化)
内存调优
Task性能调优(包含Mapper和Reducer两种类型的Task)
Shuffle网络优化(小文件合并)
RDD算子优化(RDD复用，自定义RDD)
数据本地性
容错调优
参数调优
</code></pre>
<p>大数据最怕的就是数据本地性和数据倾斜，调优Spark的重点一定是在数据本地性和数据倾斜入手</p>
<pre><code>资源分配和使用: 能够申请多少资源以及如何最优化的使用计算资源
Shuffle调优: 分布式系统必然面临的杀手级别的问题
数据倾斜： 分布式系统业务本身有数据倾斜
</code></pre>
<p>核心调优参数如下</p>
<pre><code>num-executors: 
	Yarn会按照Driver的申请去最终为当前的Application生产指定个数的Executors，
executor-memory:
	定义了每个Executor的内存，与JVM OOM密切相关，许多时候甚至决定了Spark运行的性能
	如果executor-memory超过了worker-memory 就会停止任务
	

executor-cores:
	决定了在Executors中能够并行执行的Tasks的个数

total-executor-cores:
	所有的core的个数，该数目除以executor-cores = executor个数


driver-memory: 默认是1G
spark.default.parallelize: 并行度问题，如果不设置这个参数，Spark会根据HDFS中的Block的个数去设置这一个数量，原理是每个Block对应一个Task，Spark官方的建议是每一个Core负责2-3个Task

spark.storage.memoryFraction: 默认占用60%，如果计算比较依赖历史数据则可以调高该参数，如果计算比较依赖Shuffle的话则需要降低该比例。

spark.shuffle.memoryFraction: 默认占用20%,如果计算比较依赖shuffle的话则需要调高该比例。
</code></pre>
<p>**Spark 更高性能的算子 **</p>
<p>Shuffle分开两部分，一个是Mapper端的Shuffle，另一个就是Reduce端的Shuffle，性能调优有一个很重要的总结就是尽量不使用Shuffle类的算子，能避免就尽量避免，因为一般进行Shuffle的时候，会把集群中多个节点上的同一个key汇聚在同一个节点上，例如reduceByKey。然后会优先把数据放在内存中，但如果内存不够的话会放在磁盘上。Shuffle在进行数据转去之前，为了整个集群的稳定性，它的Mapper端会把数据写到本地文件系统。这可能导致大量磁盘文件的操作。如何避免Shuffle可以考虑如下:</p>
<pre><code>1 采用Map端的Join(RDD1+RDD2) 先把一个RDD1的数据收集起来，然后再通过sc.broadcast()把数据广播到Executor上
2 如果无法避免Shuffle，退而求其次就是需要更多的机器参与Shuffle过程，这个时候就需要充分的利用Mapper端和Reducer端机制的计算资源，尽量使用Mapper端的Aggregate功能，例如aggregateByKey操作。相对于groupByKey而言，更倾向于使用reduceByKey() 和aggregateByKey() 来取代groupByKey(),因为groupbyKey() 不会进行Mapper端的操作，aggregateByKey()可以给予更多的控制。
3 如果一批一批的处理数据来说，可以使用mapPartitions(),但这个算子可能会出现OOM机会，会进行JVM的GC操作。
4 如果进行批量插入数据到数据库的话，建议使用foreachPartition() 
5 
6 官方建议使用repartitionAndSortWithPartitions()
7 数据进行复用时一般都会进行持久化persist()
8 
</code></pre>
<p>Spark开发调优</p>
<p>1 避免创建重复的RDD</p>
<pre><code>对于同一份数据，只应该创建一个RDD，不能创建多个RDD来代表同一份数据
</code></pre>
<p>2 尽可能复用同一个RDD</p>
<pre><code>由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
JavaRDD&lt;String&gt; rdd2 = rdd1.map(...)

rdd1.reduceByKey(...)
rdd2.map(...)

// 上面这个case中，其实rdd1和rdd2的区别无非就是数据格式不同而已，rdd2的数据完全就是rdd1 的子集而已，却创建了两个rdd
可以用一个rdd来执行操作

JavaPairRDD&lt;Long,String&gt; rdd1 = ...
rdd1.reduceByKey(...)
rdd1.map(tuple._2...)
</code></pre>
<p>三: 对多次使用的RDD进行持久化</p>
<pre><code>Spark中对于一个RDD执行多次算子的默认原理是这样的：每次你对一个RDD执行一个算子操作时，都会重新从源头处计算一遍，计算出那个RDD来，然后再对这个RDD执行你的算子操作。这种方式的性能是很差的。

因此对于这种情况，我们的建议是：对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略，将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时，都会直接从内存或磁盘中提取持久化的RDD数据，然后执行算子，而不会从源头处重新计算一遍这个RDD，再执行算子操作。

val rdd1 = sc.textFile(&quot;hdfs://192.168.0.1:9000/hello.txt&quot;).cache()
rdd1.map(...)
rdd1.reduce(...)
</code></pre>
<p>四: 尽量避免使用Shuffle类算子</p>
<pre><code>Shuffle过程中，会发生大量的磁盘文件读写的IO操作，以及数据的网络传输操作。磁盘IO和网络传输也是Shuffle性能较差的主要原因。

// 传统的join操作会导致Shuffle操作
因为在两个RDD中，相同的Key都需要通过网络拉取到一个节点上，由一个task进行join操作。
val rdd3= rdd1.join(rdd2)

// Boradcast + map 的join操作，不会导致shuffle操作
//使用broadcast将一个数据量较小的rdd作为广播变量
val rdd2Data = rdd2.collect()
val rdd2DataBroadCast = sc.broadcast(rdd2Data)
</code></pre>
<p>五: 使用map-side预聚合的shuffle操作</p>
<pre><code>map-side端的操作: 类似于Mapreduce中的本地combiner
map-side 预聚合之后，每个节点就会只有一条相同的key?

建议使用reduceByKey或aggregateByKey算子来替代掉groupByKey算子。因为reduceByKey和aggregateByKey算子都会使用用户自定义的函数对每个节点本地相同的key进行预聚合，而groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间进行分发和传输，性能相对来说会比较差。
</code></pre>
<p><img src="/img/spark1.png" alt="">
<img src="/img/spark2.png" alt=""></p>
<p>六 使用高性能的算子</p>
<pre><code>1 使用groupByKey 替代groupByKey
2 使用mapPartitions 替代普通的map
mapPartitions 类的算子，一次函数调用会处理一个partition所有的数据，而不是一次函数调用处理一条，性能相对来说会高一些。但是有的时候，使用mapPartitions会出现OOM的问题。因为单次函数调用就要处理掉一个partition所有的数据，如果内存不够，垃圾回收时是无法回收掉太多对象的，很可能出现oom异常，所以使用这类操作要慎重。

3 使用foreachParitions替代foreach
也是一次函数调用处理一个partition的所有数据，而不是一条数据。 

实践中发现，


4 使用filter之后进行coalesce操作
通常对一个RDD执行filter算子过滤掉RDD中较多数据后(比如过滤掉30%以上的数据)，建议使用coalesce算子，手动减少RDD的partition数量，将RDD中的数据压缩到更少的partition中去。


5 使用repartitionAndSortWithinPartition替代repartition与sort算子

repartitionAndSortWithinPartitions是Spark官网推荐的一个算子，官方建议，如果需要在repartition重分区之后，还要进行排序，建议直接使用repartitionAndSortWithinPartitions算子。因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。
</code></pre>
<p>七: 广播大变量</p>
<pre><code>在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。

因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。

通过广播方式，将变量的位置从 task 放在了Executor中
用以共享变量
</code></pre>
<p>使用Kryo优化序列化性能</p>
<pre><code>* 在算子函数中使用外部变量时，该变量会被序列化后进行网络传输
* 将自定义的类型作为RDD的泛型类型时(比如JavaRDD，Student是自定义类型)，所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口
* 使用可序列化的持久化策略时，Spark会将RDD中的每个partition都序列化成一个大的字节数组

官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。


// 创建SparkConf对象。
val conf = new SparkConf().setMaster(...).setAppName(...)
// 设置序列化器为KryoSerializer。
conf.set(&quot;spark.serializer&quot;, &quot;org.apache.spark.serializer.KryoSerializer&quot;)
// 注册要序列化的自定义类型。
conf.registerKryoClasses(Array(classOf[MyClass1], classOf[MyClass2]))
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://niuwenchen.github.io/2018/03/08/Spark-Deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackNiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SpeechAndLanguageProcessing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Spark-Deploy/" itemprop="url">Spark Deploy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-08T13:35:04+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Cluster Mode Overview</h2>
<p>Read through the <a href="http://spark.apache.org/docs/2.3.0/submitting-applications.html" target="_blank" rel="noopener">application submission guide</a> to learn about launching applications on a cluster</p>
<p><strong>Components</strong></p>
<p>Spark 应用在集群上作为独立的进程组来运行，在您的 main 程序中通过 SparkContext 来协调（称之为 driver 程序）。</p>
<p>具体的说，为了运行在集群上，SparkContext 可以连接至几种类型的 Cluster Manager（既可以用 Spark 自己的 Standlone Cluster Manager，或者 Mesos，也可以使用 YARN），它们会分配应用的资源。一旦连接上，Spark 获得集群中节点上的 Executor，这些进程可以运行计算并且为您的应用存储数据。接下来，它将发送您的应用代码（通过 JAR 或者 Python 文件定义传递给 SparkContext）至 Executor。最终，SparkContext 将发送 Task 到 Executor 以运行。</p>
<p><img src="http://spark.apache.org/docs/2.3.0/img/cluster-overview.png" alt=""></p>
<p>这里有几个需要注意的地方</p>
<ol>
<li>每个application获取到executor进程，会保持在应用的生命周期中并期望在多个线程中运行Task。在调度方面和Executor方面隔离。</li>
<li>Spark不知道底层的Cluster Manager到底是什么类型的。 只要获得Executor进程，并且彼此之间通信</li>
</ol>
<p><strong>Cluster Manager类型</strong></p>
<ul>
<li>Standalone: Spark中使得更容易来安装集群的一个简单的Cluster Manager</li>
<li>Mesos: 一个通用的Cluster Manager，可以运行Hadoop Mapredce和其他服务应用</li>
<li>Hadoop YARN: Hadoop 2的ResourceManager</li>
<li>Kubernetes – an open-source system for automating deployment, scaling, and management of containerized applications.</li>
</ul>
<p>** 提交应用 **
使用spark-submit 脚本可以提交应用程序至任何类型的集群，在 <a href="http://spark.apache.org/docs/2.3.0/submitting-applications.html" target="_blank" rel="noopener">application submitting</a>可以获得详细信息。</p>
<p>**监控 **</p>
<p>每个 driver 程序有一个 Web UI，通常在端口 4040 上，它展示了关于运行 task，executor，和存储使用情况的信息。在网页浏览器中访问这个 UI : http://&lt;driver-node&gt;:4040。<a href="http://spark.apache.org/docs/2.3.0/monitoring.html" target="_blank" rel="noopener">监控指南</a> 也描述了其它的监控选项。</p>
<p><strong>Job调度</strong></p>
<p>Spark既可以在应用间(Cluster Manager级别)，也可以在应用内(如果一个application中发生多个计算) 调度资源。<a href="http://spark.apache.org/docs/2.3.0/job-scheduling.html" target="_blank" rel="noopener">job scheduling overview</a></p>
<h2>Spark Standalone Mode</h2>
<p>安装过程</p>
<pre><code>1 解压: tar
2 local模式: 直接使用
3 Standalone模式:
	mv spark-env.sh.template  spark-env.sh
	export JAVA_HOME=/usr/lib/jdk
	export SPARK_MASTER_IP=cd-bigdata02

4 slaves
	cd-bigdata02
	cd-bigdata03
</code></pre>
<p>启动之后:</p>
<p><img src="/img/spark0.png" alt=""></p>
<pre><code>cores是worker的逻辑cpu个数
cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l
分别是4 和 8
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JackNiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackNiu</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
